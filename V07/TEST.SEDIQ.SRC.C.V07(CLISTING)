£include <stdio.h>
£include <stdlib.h>
£include <assert.h>
£include <string.h>

£define __UU
£include <strings.h>

£include "Grammarh"
£include "Lexerh"
£include "Rexxcomh"
£include "Helperh"

extern ast* global_ret;

int main()
é
    /* ast* tree; */

    getArgsRexx();

    /*
    printf("main()        : ");
    printf("argc    : (%d) çn",argc);
    printf("main()        : ");
    printf("cursc   : (%d) çn",cursc);
    printf("main()        : ");
    printf("cursl   : (%d) çn",cursl);
    printf("main()        : ");
    printf("lnumlast: (%d) çn",lnumlast);
    */

    lookahead = getNextToken();

    ast* ret = parse();

    /* Print AST */

    scr_line* screen;

    screen=init_screen();

    printf("Drawing Ast from parsing (%s)... çn",tagValuesÝret->tag~);
    printf("Drawing Ast from parsing (%d)... çn",ret->tag);

    assert(ret->tag == SENTENCE);

    affich_node(ret,screen);

    /*
    screen=draw_box(screen,"DISPLAY"    ,""         ,  1);
    screen=draw_box(screen,"LITERAL"    ,"'A'"      ,  1);
    screen=draw_box(screen,"LITERAL"    ,"'B'"      ,  0);
    screen=draw_box(screen,"IDENTIFIER" ,""         ,  0);
    screen=draw_box(screen,"NAME"       ,"WS-NAME"  ,  1);
    screen=draw_box(screen,"QUALIF"     ,""         ,  0);
    screen=draw_box(screen,""           ,"QUALIF-1" ,  1);
    screen=draw_box(screen,""           ,"QUALIF-2" ,  0);
    screen=draw_box(screen,"SUBSCR"     ,""         , -1);
    screen=draw_box(screen,""           ,"SUBSCR-1" ,  1);
    screen=draw_box(screen,""           ,"SUBSCR-2" ,  0);
    screen=draw_box(screen,"REFMOD"     ,""         , -1);
    screen=draw_box(screen,""           ,"REFMOD-1" ,  1);
    screen=draw_box(screen,""           ,"REFMOD-2" ,  0);
    screen=draw_box(screen,"LITERAL"    ,"'C'"      , -2);

    screen=draw_box(screen,"MOVE"       ,""         , -1);
    screen=draw_box(screen,"IDENTIFIER" ,""         ,  1);
    screen=draw_box(screen,"NAME"       ,"WS-DATE-1",  1);
    screen=draw_box(screen,"QUALIF"     ,""         ,  0);
    screen=draw_box(screen,""           ,"QUALIF-1" ,  1);
    screen=draw_box(screen,"SUBSCR"     ,""         , -1);
    screen=draw_box(screen,""           ,"SUBSCR-1" ,  1);
    screen=draw_box(screen,"IDENTIFIER" ,""         , -2);
    screen=draw_box(screen,"NAME"       ,"WS-DATE-2",  1);
    */

    printf("Printing Ast from parsing (%s)... çn",tagValuesÝret->tag~);
    print_boxes(screen);

    free_node(ret);

    /*
    assert(tree->tag == SENTENCE);

    printf("Tree nb statement :(%i)çn",
            tree->node.sentence.nb_statement);

    printf("main() end  ! çn free tree... ");

    free(tree);

    printf(" Done. çn");
    */
    printf(" END MAIN. çn");
    return 0;
è
£include <stdio.h>
£include <stdlib.h>
£include <stddef.h>

£include "Grammarh"
£include "Lexerh"
£include "asth"

£define MAX_FP_ARR   12
£define MAX_STR_ARR  20
£define COUNT_OF( arr) (sizeof(arr)/sizeof(0Ýarr~))

ast* global_ret;

/* Typedef pour function to Pointer */
typedef int (*IntFunc)(void);

/* Typedef pour array of string with length */
typedef struct str_arré
   int    len;
   char*  arr ÝMAX_STR_ARR~;
è str_arr;

/* Typedef pour Struct de :         */
/* - Pointer to function            */
/* - lookahead condition 1          */
/* - lookahead condition 2          */
typedef struct fp_té
   IntFunc fp;
   str_arr cond_1;
   str_arr cond_2;
   int    id;
è fp_t;

/* Typedef pour array of fp_t with length */
typedef struct fp_t_nodé
   fp_t              val;
   struct fp_t_nod* next;
è fp_t_nod;

fp_t_nod* alim_clauses();
int tkn_in_array (str_arr);
fp_t_nod* delete_clauses(fp_t_nod*,fp_t_nod*);

context _context=é"","","","","",""è;
context save;

ast* build_literal(int);
                        /*----------*/
ast*
parse()
é

    ast* ret=NULL;

    if(dclrtn())é
      ;
    è

    else if (ret=sntce())é
      ;
    è

    else return NULL;

    printf("ret   tag (%d) çn",ret->tag);

    return ret;
è


/*---------------------------------  working storage        ---------*/
int
working_storage_section()é


    if(match_val("WORKING-STORAGE"))é
       ;
    è
    else return 0;

    if(match_val("SECTION"))é
       ;
    è
    else return 0;

    if(match_val("."))é
       ;
    è
    else return 0;

    /* 1-49, 66, 77 et 88 */
    while  (equal_attr("LEVEL NUMBER"))é

           if(dclrtn())é
              ;
           è
           else return 0;
    è

    printf("Rule recognized: working_storage_section çn");

    return 1;
è

/*---------------------------------  Sentence and Statement ---------*/

ast*
sntce()
é
    ast* ret=NULL;
    ast* stmnt_ret=NULL;

    int nb_statement =  0;
    ast* list_statement = NULL;

    printf("Trying to match rule : sntce çn");

    while((equal_val("MOVE"))         !!
          (equal_val("DISPLAY"))      !!
          (equal_val("INITIALIZE")))é

      if(stmnt_ret=stmnt())é

         nb_statement++;
         list_statement = append_list(list_statement,stmnt_ret);

    /*  (ret->node.sentence.nb_statement)++; */
    /* bug tres bizzare: list_statement->next nest pas null mai egale
       au list_statement, le patch est provisoire eet peux causer
       perte de noeud si append de plusieur noeud a la fois */

    /*  ret->node.sentence.list_statement=append_list
                        (ret->node.sentence.list_statement,stmnt_ret);
    */


    /* xxx */ printf("5 nb_statement   (%d)çn",nb_statement);
    /* xxx */ printf("5 list_statement (%d)çn",list_statement);

    /* xxx */ printf("5 list_statement->next (%d)çn",
                                                 list_statement->next);

      è
      else return NULL;

    è

/*  BUILD AST : SENTENCE */
    ret = make_sentence(nb_statement,list_statement);

    /* optional */
    if (equal_val("."))
        consume();

    printf("Rule recognized: sntce çn");

    printf("ret   tag (%d) çn",ret->tag);
    return ret;
è

ast*
stmnt()é
    printf("Trying to match rule : stmnt çn");

    ast* ret=NULL;

    if (equal_val("MOVE"))é

       if (move())é
           ;
       è
       else return NULL;

    è
    else if (equal_val("INITIALIZE"))é

       if (intlz())é
           ;
       è
       else return NULL;
    è
    else if(equal_val("DISPLAY"))é

       if (ret=dsply())é
           ;
       è
       else return NULL;
    è
    else return NULL;


    printf("Rule recognized: stmnt çn.");
    printf("ret   tag (%d) çn",ret->tag);
    /* xxx */ printf("3 stmnt ret (%d)çn",ret);
    /* xxx */ printf("3 stmnt ret->next (%d)çn",ret->next);

    return ret;
è

/*--------------------  move, display and initialize Statement ------*/

int
move()
é
    printf("Trying to match rule : move çn");
/*
    if (move_2()) é
        ;
    è
    else if (move_1())é
        ;
    è
    else return 0;
*/
    if(match_val("MOVE"))é
        ;
    è
    else return 0;

    if (move_oprnd())é
        ;
    è
    else return 0;

    printf("Rule recognized: move çn");
    return 1;
è

ast*
dsply()
é
    printf("Trying to match rule : dsply çn");

    ast* ret=NULL;
    ast* sub_ret=NULL;

/*  BUILD AST : DISPLAY_STM */
    ret = make_display(0,0,"",0,NULL);

    /* xxx */ printf("1 display ret (%d)çn",ret);
    /* xxx */ printf("1 display ret->next (%d)çn",ret->next);

    if(match_val("DISPLAY"))é
        ;
    è
    else return NULL;

    if(sub_ret=ids_litrs())é
    /* xxx */ printf("after ids_litrs çn");

        ret->node.display_stm.list_operand=
        append_list(ret->node.display_stm.list_operand,sub_ret);
        /* attention un append peut ajouter plus qu'un seul operand */
        (ret->node.display_stm.nb_operand)++;
    è
    else return NULL;

    /* optional */
    if (equal_val("UPON"))é
       if(dsply_upon())é
           ret->node.display_stm.bool_upon =1;
       è
       else return NULL;
    è

    /* optional */
    if ((equal_val("WITH"))!!(equal_val("NO")))é
       if(dsply_noadv())é
           ret->node.display_stm.bool_no_adv =1;
       è
       else return NULL;
    è

    printf("Rule recognized: dsply çn");

    printf("ret   tag (%d) çn",ret->tag);
    /* xxx */ printf("2 display ret (%d)çn",ret);
    /* xxx */ printf("2 display ret->next (%d)çn",ret->next);

    return ret;
è

int
intlz()
é
    printf("Trying to match rule : intlz çn");

    if(match_val("INITIALIZE"))é
        ;
    è
    else return 0;

    if(ids())é
        ;
    è
    else return 0;

    /* optional */
    if (equal_val("REPLACING"))é

       if(intlz_rplc())é
           ;
       è
       else return 0;

    è

    printf("Rule recognized: intlz çn");

    return 1;
è

/*------------------ initialize body --------------------------------*/

int
intlz_rplc ()
é
    printf("Trying to match rule : intlz_rplc çn");

    if(match_val("REPLACING"))é
        ;
    è
    else return 0;

    if(intlz_rplc_oprnds())é
        ;
    è
    else return 0;

    printf("Rule recognized: intlz_rplc çn");

    return 1;
è

int
intlz_rplc_oprnds()
é
    printf("Trying to match rule : intlz_rplc_oprnds çn");

    int ret = 0;

    while((equal_val("ALPHABETIC"))   !!
          (equal_val("ALPHANUMERIC")) !!
          (equal_val("NUMERIC")))    é

       if(intlz_rplc_oprnd())é
           ;
       è
       else return 0;
       ret = 1;
    è

    if (ret == 1)   printf("Rule recognized: intlz_rplc_oprnds çn");
    return ret;
è

int
intlz_rplc_oprnd()é

    printf("Trying to match rule : intlz_rplc_oprnd çn");

    if(chartype())é
        ;
    è
    else return 0;

    if(match_val("BY"))é
        ;
    è
    else return 0;

    if (id_litr())é
        ;
    è
    else return 0;

    printf("Rule recognized: intlz_rplc_oprnd çn");
    return 1;
è

int
chartype()
é
    printf("Trying to match rule : chartype çn");

    if(match_val("ALPHABETIC"))é
        ;
    è
    else if (match_val("ALPHANUMERIC"))é
        ;
    è
    else if (match_val("NUMERIC"))é
        ;
    è
    else return 0;

    printf("Rule recognized: chartype çn");
    return 1;
è

/*-------------------------- move body ------------------------------*/
/*
int move_1()é

    printf("Trying to match rule : move_1 çn");

    if(match("MOVE"))é
        ;
    è
    else return  0;

    if(id_litr())é
        ;
    è
    else return  0;

    if(match("TO"))é
        ;
    è
    else return  0;

    if(ids())é
        ;
    è
    else return  0;

    printf("Rule recognized: move_1 çn");
    return 1;

è
*/
/* backtracking ? */
/*
int move_2()
é
    printf("Trying to match rule : move_2 çn");

    if(match("MOVE"))é
        ;
    è
    else return  0;

    if(corspnd())é
        ;
    è
    else return  0;

    printf("Rule recognized: move_2 çn");

    return 1;
è
*/
int
move_oprnd()é

    printf("Trying to match rule : move_oprnd çn");

    if((equal_val("CORR")) !!
       (equal_val("CORRESPONDING"))) é
       if(corspnd())é
          ;
       è
       else return 0;

       if(id())é
          ;
       è
       else return 0;

       if(match_val("TO"))é
          ;
       è
       else return 0;

       if(id())é
          ;
       è
       else return 0;

    è
    else é

       if(id_litr())é
          ;
       è
       else return 0;

       if(match_val("TO"))é
          ;
       è
       else return 0;

       if(ids())é
          ;
       è
       else return 0;
    è

    /*
    if(id_litr())é
        if(match("TO"))é
            if(ids())é
                ;
            è
            else return  0;
        è
        else return  0;
    è
    else é
        if(corspnd())é
            if(id())é
                if(match("TO"))é
                    if(id())é
                        ;
                    è
                    else return  0;
                è
                else return  0;
            è
            else return  0;
        è
        else return  0;
    è
    */
    printf("Rule recognized: move_oprnd çn");
    return 1;

è

int
corspnd()
é
    printf("Trying to match rule : corspnd çn");

    if(match_val("CORRESPONDING"))é
        ;
    è
    else if (match_val("CORR"))é
        ;
    è
    else return  0;

    printf("Rule recognized : corspnd çn");
    return 1;
è

/*--------------------------- display body --------------------------*/

int
dsply_upon()
é
    printf("Trying to match rule : dsply_upon çn");

    if(match_val("UPON"))é
        ;
    è
    else return  0;

    if(dsply_upon_oprnd())é
        ;
    è
    else return  0;

    printf("Rule recognized : dsply_upon çn");

    return 1;
è

int
dsply_noadv()
é
    printf("Trying to match rule : dsply_noadv çn");

    /* optional */
    if (match_val("WITH"))é
        ;
    è

    if (match_val("NO"))é
        ;
    è
    else return  0;

    if (match_val("ADVANCING"))é
        ;
    è
    else return  0;

    printf("Rule recognized : dsply_noadv çn");

    return 1;
è

int
dsply_upon_oprnd()
é
    printf("Trying to match rule : dsply_upon_oprnd çn");

    if(mnemo_or_envir())é
        ;
    è
    else return  0;

    printf("Rule recognized : dsply_upon_oprnd çn");
    return 1;
è

int
mnemo_or_envir()
é
    printf("Trying to match rule : mnemo_or_envir çn");

    if(id_name())é
        ;
    è
    else return  0;

    printf("Rule recognized : mnemo_or_envir çn");
    return 1;
è


/*----------------------  Identifiers and Literals ------------------*/

ast*
ids_litrs()
é
    printf("Trying to match rule : ids_litrs çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    while(sub_ret=id_litr())é

        ret=append_list(ret,sub_ret);
        ;
    è

    if (ret)     printf("Rule recognized: ids_litrs (%d) çn",ret);
    printf("ids_litrs     (%s) address(%d)çn",ret->node.literal.value
                                             ,ret);

    return ret;
è

ast*
id_litr() é

    printf("Trying to match rule : id_litr çn");

    ast* ret=NULL;

    if(equal_type("IDENTIFIER") !! equal_attr("SPECIAL REGISTER"))é

       if (ret=id())é
           ;
       è
       else return NULL;

    è

    else é

       if (ret=litr())é
           printf("id_litr (%s) address(%d)çn",ret->node.literal.value
                                              ,ret);
           ;
       è
       else return NULL;

    è

    printf("Rule recognized: id_litr çn");
    return ret;
è

ast*
ids() é

    printf("Trying to match rule : ids çn");

    ast* ret     =NULL;
    ast* sub_ret =NULL;

    while(equal_type("IDENTIFIER") !! equal_attr("SPECIAL REGISTER"))é
       if(sub_ret=id())é

          ret = append_list(ret,sub_ret);

       è
       else return NULL;
    è

    if (ret)     printf("Rule recognized: ids çn");
    return ret;
è

/*-----------------------  Identifier and Literal -------------------*/

ast*
litr() é

    printf("Trying to match rule : litr çn");

    ast* ret=NULL;


    /* figurative constants */
    if (equal_attr("FIGURATIVE CONST"))é

        if (ret=figurative_constants())é
           ;
        è
        else return NULL;
    è
    else

    /* nonnumeric and numeric literals  */
    if (equal_type("LITERAL"))é

    /*  BUILD AST : LITERAL */
        ret=build_literal(0);
    printf("1 liter (%s) address(%d) char_len(%d)"ç
           "  single quote (%d) alphanumeric (%d)"
                       ,ret->node.literal.value
                       ,ret
                       ,ret->node.literal.char_length
                       ,ret->node.literal.bool_singl_q
                       ,ret->node.literal.bool_alphanumeric);
        global_ret = ret;
        consume();
    printf("2 liter (%s) address(%d) char_len(%d)"ç
           "  single quote (%d) alphanumeric (%d)"
                       ,ret->node.literal.value
                       ,ret
                       ,ret->node.literal.char_length
                       ,ret->node.literal.bool_singl_q
                       ,ret->node.literal.bool_alphanumeric);
    è
    else return  NULL;

    printf("Rule recognized: litr çn");
    printf("ret tag (%s)(%d) çn",tagValuesÝret->tag~,ret->tag);
    return ret;
è

ast*
figurative_constants() é

    ast* ret=NULL;
    ast* figurative_ret=NULL;

    int bool_all=0;

    printf("Trying to match rule : figurative_constants çn");

    if(equal_val("ALL"))é

       bool_all = 1;
       consume();

    è
       /* QUOTED  est présent ici dans le cas ou ALL est consommé */
    if (equal_attr("QUOTED")       !!
        equal_val ("ZERO")         !!
        equal_val ("ZEROS")        !!
        equal_val ("ZEROES")       !!
        equal_val ("SPACE")        !!
        equal_val ("SPACES")       !!
        equal_val ("HIGH-VALUE")   !!
        equal_val ("HIGH-VALUES")  !!
        equal_val ("LOW-VALUE")    !!
        equal_val ("LOW-VALUES")   !!
        equal_val ("QUOTE")        !!
        equal_val ("QUOTES"))é

       /*  BUILD AST : LITERAL */
       figurative_ret = build_literal(bool_all);
       ret=append_list(ret,figurative_ret);

       consume();

    è
    else return NULL;

    printf("Rule recognized: figurative_constants çn");
    return ret;
è

ast*
id() é

    printf("Trying to match rule : id çn");

    ast* ret=NULL;
    ast* sub_ret=NULL;

    if (equal_attr("SPECIAL REGISTER"))é
       if (sub_ret=special_register())é
          ret=append_list(ret,sub_ret);
       è
    è
    else

    if (sub_ret=id_name())é
          ret=append_list(ret,sub_ret);
        ;
    è
    else return NULL;

    /* optional */
    if (equal_val("OF"))é
       if (sub_ret=id_qualif())é
           ;
       è
       else return  NULL;
    è

    /* optional subscript and refmodifier */
    if (equal_val("("))é

        /* une fois rentré, ca devient obligatoire */
        if (sub_ret=id_subs_refm())é
           ;
        è
        else return  NULL;
    è

    printf("Rule recognized: id çn");
    return ret;
è


ast*
special_register() é

    printf("Trying to match rule : special_register çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    int bool_length=0;
    int bool_address=0;

    /* gestion de special register avec OF */
    if ((equal_val("LENGTH")) !! (equal_val("ADDRESS")))é

       if(equal_val("LENGTH"))  bool_length  =1;
       if(equal_val("ADDRESS")) bool_address =1;

       consume();

       if(match_val("OF"))é
          ;
       è
       else return NULL;

       if (sub_ret=id())é

           ret=append_list(ret,sub_ret);
           ret->node.identifier.bool_length =bool_length;
           ret->node.identifier.bool_address=bool_address;

       è
       else return NULL;

    è
    else

       if(equal_attr("SPECIAL REGISTER"))é
          ret=make_identifier(bool_length,bool_address,
                              get_token_val(),NULL,NULL,NULL,NULL);
          consume();
       è
       else return NULL;


    printf("Rule recognized: special_register çn");
    return ret;
è

ast*
id_name_qualif()
é
    ast* ret    =NULL;
    ast* sub_ret=NULL;

    ret = make_ident_name_qualif(NULL,NULL);


    if (sub_ret=id_name())é
        ret->node.ident_name_qualif.name=sub_ret;
    è
    else return NULL;

    /* optional */
    if (equal_val("OF"))é
       if (sub_ret=id_qualif())é
          ret->node.ident_name_qualif.qualif=sub_ret;

       è
       else return NULL;
    è

    return ret;

è

ast*
id_names()
é
    ast* ret    =NULL;
    ast* sub_ret=NULL;

    printf("Trying to match rule : id_names çn");

    while(equal_type("IDENTIFIER"))é

        if (sub_ret=id_name())é

           ret=append_list(ret,sub_ret);
        è
        else return NULL;

    è

    if(ret) printf("Rule recognized: id_names çn");

    return ret;
è

ast*
id_name()
é
    printf("Trying to match rule : id_name çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    if (equal_type("IDENTIFIER"))é
        ret=make_ident_name(get_token_len(),get_token_val());
        consume();
    è
    else return NULL;

    printf("Rule recognized: id_name çn");
    return ret;
è

ast*
id_qualif()
é
    printf("Trying to match rule : id_qualif çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;
    ret=make_ident_qualif(NULL);

    while (equal_val("OF"))é
       if(sub_ret=id_qualif_oprnd())é
           ret->node.ident_qualif.list_qualif=
               append_list(ret->node.ident_qualif.list_qualif,sub_ret);
       è
       else return NULL;

    è

    if (ret)     printf("Rule recognized: id_qualif çn");
    return ret;

è

ast*
id_qualif_oprnd ()é

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    printf("Trying to match rule : id_qualif_oprnd çn");

    if (match_val("OF"))é
        ;
    è
    else return NULL;

    if(sub_ret=id_name())é
        ret=append_list(ret,sub_ret);
    è
    else return NULL;

    printf("Rule recognized: id_qualif_oprnd çn");
    return ret;
è
/* continue implementing ast here ... */
ast*
id_subs_refm()é

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    printf("Trying to match rule : id_subs_refm çn");

    if (match_val("("))é
        ;
    è
    else return NULL;

    if(sub_ret=id_oprnd_1_subs_refm())é
        ;
    è
    else return NULL;

    if(sub_ret=id_subs_refm_rest())é
        ;
    è
    else return NULL;

    printf("Rule recognized : id_subs_refm çn");
    return ret;

è

ast*
id_oprnd_1_subs_refm()é


    ast* ret    =NULL;
    ast* sub_ret=NULL;

    printf("Trying to match rule : id_oprnd_1_subs_refm çn");

    if (sub_ret=arith_expr())é
        ;
    è
    else return NULL;

    printf("Rule recognized : id_oprnd_1_subs_refm çn");
    return ret;

è

ast*
id_subs_refm_rest()é

    printf("Trying to match rule : id_subs_refm_rest çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    if (equal_val(":"))é
        if (sub_ret=id_refm_rest())é
           ;
        è
        else return NULL;
    è
    else if (sub_ret=id_subs_rest())é

             if (equal_val("("))é
                if (sub_ret=id_refmodif())é
                    ;
                è
                else return  NULL;
             è

    è

    else return  NULL;

    printf("Rule recognized : id_subs_refm_rest çn");
    return  ret;

è

ast*
id_refm_rest()
é
    printf("Trying to match rule : id_refm_rest çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;


    if (match_val(":"))é
        ;
    è
    else return  NULL;

    if(sub_ret=refmodif_length())é
        ;
    è
    else return  NULL;

    if (match_val(")"))é
        ;
    è
    else return  NULL;

    printf("Rule recognized : id_refm_rest çn");
    return  ret;

è

ast*
id_subs_rest()
é
    printf("Trying to match rule : id_subs_rest çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    if (match_val(")"))é
        ;
    è
    else
    é
        if(sub_ret=subscripts())é

            if (match_val(")"))é
                ;
            è
            else return  NULL;
        è
        else return  NULL;
    è

    printf("Rule recognized : id_subs_rest çn");
    return  ret;

è

ast*
id_subscript()
é
    printf("Trying to match rule : id_subscript çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;


    if (match_val("("))é
        ;
    è
    else return  NULL;

    if(sub_ret=subscripts())é
        ;
    è
    else return  NULL;

    if (match_val(")"))é
        ;
    è
    else return  NULL;

    printf("Rule recognized: id_subscript çn");
    return ret;
è

ast*
id_refmodif()
é
    printf("Trying to match rule : id_refmodif çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;


    if (match_val("("))é
        ;
    è
    else return  NULL;

    if(sub_ret=refmodif())é
        ;
    è
    else return  NULL;

    if (match_val(")"))é
        ;
    è
    else return  NULL;

    printf("Rule recognized: id_refmodif çn");
    return ret;
è


/*---------------------------  Identifier body ----------------------*/

ast*
subscripts()
é
    printf("Trying to match rule : subscripts çn");


    ast* ret    =NULL;
    ast* sub_ret=NULL;

    while(sub_ret=subscript())é
        ;
    è

    if (ret)     printf("Rule recognized: subscripts çn");
    return ret;
è

ast*
subscript()
é
    printf("Trying to match rule : subscript çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    if (sub_ret=arith_expr2())é
        ;
    è
    else return  NULL;

    printf("Rule recognized: subscript çn");
    return ret;
è

ast*
refmodif()
é

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    printf("Trying to match rule : refmodif çn");

    if(sub_ret=charleftpos())é
        ;
    è
    else return  NULL;

    if(match_val(":"))é
        ;
    è
    else return  NULL;

    if(sub_ret=refmodif_length())é
        ;
    è
    else return  NULL;

    printf("Rule recognized: refmodif çn");
    return ret;
è

ast*
charleftpos()
é

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    printf("Trying to match rule : charleftpos çn");

    if (sub_ret=arith_expr())é
        ;
    è
    else return  NULL;

    printf("Rule recognized: charleftpos çn");
    return ret;
è

ast*
refmodif_length()
é
    printf("Trying to match rule : refmodif_length çn");

    /*optional */

    ast* ret    =NULL;
    ast* sub_ret=NULL;


    if(§equal_val(")"))é
       if (sub_ret=arith_expr())é
           ;
       è
       else return NULL;
    è

    printf("Rule recognized: refmodif_length çn");
    return ret;
è


/*-------------------------  Arithmetic expression ------------------*/
/*
int arith_expr_old()
é
    printf("Trying to match rule : arith_expr_old çn");

    if(arith_expr_oprnd())é
        ;
    è
    else return  0;

       optional
    if(arith_expr_oprtn())é
        if(arith_expr())é
            ;
        è
        else return  0;
    è

    printf("Rule recognized: arith_expr_old çn");
    return 1;
è
*/
ast*
arith_expr()
é
    printf("Trying to match rule : arith_expr çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;


    if(sub_ret=times_div())é
        ;
    è
    else return  NULL;

    while((equal_val("+")) !! (equal_val("-")))é

       consume();

       if(sub_ret=times_div())é
          ;
       è
       else return NULL;

    è

    printf("Rule recognized: arith_expr çn");
    return ret;
è

ast*
times_div()
é
    printf("Trying to match rule : times_div çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;


    if(sub_ret=power())é
        ;
    è
    else return  NULL;

    while((equal_val("*")) !! (equal_val("/")))é

       consume();

       if(sub_ret=power())é
          ;
       è
       else return NULL;

    è

    printf("Rule recognized: times_div çn");
    return ret;
è

ast*
power()
é
    printf("Trying to match rule : power çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;


    if ((equal_val("+")))é

       consume();

    è
    else if((equal_val("-")))é

       consume();

    è

    if(sub_ret=basis())é
        ;
    è
    else return  NULL;

    while((equal_val("**")))é

       consume();

       if(sub_ret=basis())é
          ;
       è
       else return NULL;

    è

    printf("Rule recognized: power çn");
    return ret;
è

ast*
basis()
é
    printf("Trying to match rule : basis çn");


    ast* ret    =NULL;
    ast* sub_ret=NULL;

    if ((equal_type("IDENTIFIER"))!!(equal_attr("SPECIAL REGISTER")))é

       if (sub_ret=id())é
          ;
       è
       else return NULL;
    è
    else if((equal_val("(")))é

            /* bug de caca ! ne pas oublier de consommer le ( */
            consume();

            if (sub_ret=arith_expr())é
               ;
            è
            else return NULL;

            if (match_val(")"))é
               ;
            è
            else return NULL;
         è
            /* ZERO/ZEROS/ZEROS inclut */
    else if (equal_attr("NUMERIC"))é

            if(equal_type("LITERAL"))é

               if (sub_ret=litr())é
                  ;
               è
               else return NULL;
            è
            else /* KEYWORD (ZERO/ZEROS/ZEROS) */
            é
               consume();
            è

         è

    else return NULL;

    printf("Rule recognized: basis çn");
    return ret;
è

ast*
arith_expr2()
é
    printf("Trying to match rule : arith_expr2 çn");

    ast* ret    =NULL;
    ast* sub_ret=NULL;

    if((equal_attr("INTEGER"))&&(equal_attr("UNSIGNED")))é

        consume();

    è
    else if(sub_ret=id_name_qualif())é

            /* optional */
            if((equal_val("+"))!!(equal_val("-"))) é

               consume();

               if((equal_attr("INTEGER"))&&(equal_attr("UNSIGNED")))é

                  consume();

               è
               else return  NULL;
            è

         è
    else return NULL;

    printf("Rule recognized: arith_expr2 çn");
    return ret;
è
/*
int arith_expr2_old()
é
    printf("Trying to match rule : arith_expr2_old çn");

    if(arith_expr_oprnd())é
        ;
    è
    else return  0;

       optional
    if(arith_expr_oprtn())é
        if(arith_expr_oprnd())é
            ;
        è
        else return  0;
    è

    printf("Rule recognized: arith_expr2_old çn");
    return 1;
è

int arith_expr_oprnd()
é
    printf("Trying to match rule : arith_expr_oprnd çn");

    if (match("INTEGER"))é
        ;
    è
    else if (id_name_qualif())é
        ;
    è
    else return  0;

    printf("Rule recognized: arith_expr_oprnd çn");
    return 1;
è

int arith_expr_oprtn()
é
    printf("Trying to match rule : arith_expr_oprtn çn");

    if (match("+"))é
        ;
    è
    else if (match("-"))é
        ;
    è
    else if (match("*"))é
        ;
    è
    else return  0;

    printf("Rule recognized: arith_expr_oprtn çn");
    return 1;
è
*/
/*---------------------- Data declaration    ------------------------*/
int
dclrtn()é

    printf("Trying to match rule : dclrtn çn");

    if  (equal_attr("LEVEL NUMBER")&&
        §equal_val ("66")          &&
        §equal_val ("88")          )é

         consume();

        if (equal_type("IDENTIFIER"))é

           if (id_name())é
              ;
           è
           else return  0;
        è
        else if (equal_val("FILLER"))é

                consume();
             è
             else ;

        if (data_desc())é
           ;
        è
        else return  0;

        if (match_val("."))é
           ;
        è
        else return  0;

    è
    else if (equal_attr("LEVEL NUMBER")&&
             equal_val ("66")          )é

             consume();

        if (id_name())é
           ;
        è
        else return  0;

        if (renames_cl())é
           ;
        è
        else return  0;

        if (match_val("."))é
           ;
        è
        else return  0;

    è
    else if (equal_attr("LEVEL NUMBER")&&
             equal_val ("88")          )é

             consume();

        if (cond_name())é
           ;
        è
        else return  0;

        if (cond_val_cl())é
           ;
        è
        else return  0;

        if (match_val("."))é
           ;
        è
        else return  0;

    è
    else return 0;

    printf("Rule recognized: dclrtn çn");
    return 1;

è
/*---------------------- Declaration  body   ------------------------*/

int
cond_name()
é
    printf("Trying to match rule : cond_name çn");

    if (match_type("IDENTIFIER"))é
        ;
    è
    else return  0;

    printf("Rule recognized: cond_name çn");
    return 1;
è

/*------*/

int
data_desc()
é
    printf("Trying to match rule : data_desc çn");


    /* Not all clauses are compatible with each other */
    /* Semantic for further analysis and elimination */


    /* add permutation */
    /* Union for all the clause to permute */
    /* an array of function pointer        */
    /* a while loop                        */
    /* if a clause is found                */
    /* take it off from the array          */

    /* Known bug : normalement global peut venir avant redefines */
    /* Mais pour nous redefines doit obligatoirement etre en premier */

    if (equal_val("REDEFINES"))é

       if (data_redefines_cl())é
          ;
       è
       else return  0;
    è

    /* Array of clauses to permute      */
    fp_t_nod *clauses;
    clauses = alim_clauses();
    print_clauses(clauses);

    fp_t_nod *iterator= clauses;

    printf("Permutation loop start ... çn list head (%d)çn",iterator);

    /* parcourir la liste chainée */
    while (iterator §= NULL)é

   /*printf("Permutation loop .iterator (%d)çn",iterator);
   */  /* Known bug : 'IS' is accepted before each clause !! */
       /* if should be for external et gloabal only          */
       /* A deleguer a l'analyse semantique                  */
       if (equal_val("IS"))é

          consume();

       è

       /* if lookahead match    */
       if (tkn_in_array(iterator->val.cond_1))é
          /* invoquer la function pointer */
          if (iterator->val.fp())é
             printf("Function pointer (%d) invoked after cond çn",
                    iterator->val.id);
          è
          else return 0;

          /* Reduire la ligne de la liste chainée */
          clauses = delete_clauses(clauses,iterator);
          /* Repointer vers la tete de la chaine */
          iterator = clauses;
       è
       else
       é
          /* pointer vers le noeud suivant */
          iterator = iterator->next;

       è
    è

    /* Not implemented clause : Like */
    /* Not implemented clause : Typedef */

    /*
    if (tknEqual("IS"))é

       if (match("IS"))é
          ;
       è
       else return  0;
    è

    if (tknEqual("EXTERNAL"))é

       if (data_external_cl())é
          ;
       è
       else return  0;
    è

    if (tknEqual("BLANK"))é

       if (data_blankzero_cl())é
          ;
       è
       else return  0;
    è
    */
    /* Not implemented clause : Format */
    /*
    if (tknEqual("IS"))é

       if (match("IS"))é
          ;
       è
       else return  0;
    è

    if (tknEqual("GLOBAL"))é

       if (data_global_cl())é
          ;
       è
       else return  0;
    è

    if ((tknEqual("JUST")) !!
        (tknEqual("JUSTIFIED")) )é

       if (data_just_cl())é
          ;
       è
       else return  0;
    è

    if (tknEqual("OCCURS"))é

       if (data_occurs_cl())é
          ;
       è
       else return  0;
    è

    if ((tknEqual("PIC")) !!
        (tknEqual("PICTURE")) )é

       if (data_pic_cl())é
          ;
       è
       else return  0;
    è

    if ((tknEqual("SIGN")) !!
        (tknEqual("LEADING")) !!
        (tknEqual("TRAILING")))é

       if (data_sign_cl())é
          ;
       è
       else return  0;
    è


    if (tknEqual("VALUE"))é

       if (data_value_cl())é
          ;
       è
       else return  0;
    è


    if ((tknEqual("SYNC")) !!
        (tknEqual("SYNCHRONIZED")) )é

       if (data_sync_cl())é
          ;
       è
       else return  0;
    è
    */
    /* Not implemented clause : Type    */
    /*
    if ((tknEqual("USAGE"))           !!
        (tknEqual("BINARY"))          !!
        (tknEqual("COMPUTATIONAL"))   !!
        (tknEqual("COMP"))            !!
        (tknEqual("COMPUTATIONAL-1")) !!
        (tknEqual("COMP-1"))          !!
        (tknEqual("COMPUTATIONAL-2")) !!
        (tknEqual("COMP-2"))          !!
        (tknEqual("COMPUTATIONAL-3")) !!
        (tknEqual("COMP-3"))          !!
        (tknEqual("COMPUTATIONAL-4")) !!
        (tknEqual("COMP-4"))          !!
        (tknEqual("DISPLAY"))         !!
        (tknEqual("DISPLAY-1"))       !!
        (tknEqual("INDEX"))           !!
        (tknEqual("PACKED-DECIMAL"))  !!
        (tknEqual("POINTER"))         !!
        (tknEqual("PROCEDURE-POINTER")))é

       if (data_usage_cl())é
          ;
       è
       else return  0;
    è
    */
    printf("Rule recognized: data_desc çn");
    return 1;
è

/*--------------------- Data declaration functions ------------------*/

int
data_redefines_cl()é

    printf("Trying to match rule : data_redefines_cl çn");

    if (match_val("REDEFINES"))é
       ;
    è
    else return 0;

    if (id_name())é
       ;
    è
    else return 0;

    printf("Rule recognized: data_redefines_cl çn");
    return 1;
è

/*------*/

int
data_external_cl()é

    printf("Trying to match rule : data_external_cl  çn");

    if (match_val("EXTERNAL"))é
       ;
    è
    else return 0;


    printf("Rule recognized: data_external_cl  çn");
    return 1;
è

/*------*/

int
data_blankzero_cl()é

    printf("Trying to match rule : data_blankzero_cl çn");

    if (match_val("BLANK"))é
       ;
    è
    else return 0;

    if (equal_val("WHEN"))é

       consume();

    è

    if (match_val("ZERO"))é
       ;
    è
    else return 0;


    printf("Rule recognized: data_blankzero_cl çn");
    return 1;
è

/*------*/

int
data_global_cl()é

    printf("Trying to match rule : data_global_cl çn");

    if (match_val("GLOBAL"))é
       ;
    è
    else return 0;


    printf("Rule recognized: data_global_cl çn");
    return 1;
è

/*------*/

int
data_just_cl()é

    printf("Trying to match rule : data_just_cl çn");

    if ((equal_val("JUST"))!!(equal_val("JUSTIFIED")))é

       consume();

    è

    if ((equal_val("RIGHT")))é

       consume();

    è

    printf("Rule recognized: data_just_cl çn");
    return 1;
è

/*------*/

int
data_occurs_cl()é

    printf("Trying to match rule : data_occurs_cl çn");

    if (match_val("OCCURS"))é
       ;
    è
    else return 0;

    if ((equal_attr("INTEGER"))!!(equal_attr("UNSIGNED")))é

       consume();
    è
    else return 0;

    /* Format 2 */
    if ((equal_val("TO")))é

        consume();

        if ((equal_attr("INTEGER"))!!(equal_attr("UNSIGNED")))é

           consume();
        è
        else return 0;

        if ((equal_val("TIMES")))é

           consume();
        è

        if (match_val("DEPENDING"))é
           ;
        è
        else return 0;

        if ((equal_val("ON")))é

           consume();
        è

        if (id_name())é
           ;
        è
        else return 0;

        /* Key-indexed-by phrase */

        if ((equal_val("ASCENDING")) !!
            (equal_val("DESCENDING")) )é

            if (data_index_key_cls())é
               ;
            è
            else return 0;
        è

        if ((equal_val("INDEX")))é

            if (data_index_by_cl())é
               ;
            è
            else return 0;
        è

    è

    /* Format 1 */

    else é

        if ((equal_val("TIMES")))é

           consume();
        è

        /* Key-indexed-by phrase */

        if ((equal_val("ASCENDING")) !!
            (equal_val("DESCENDING")) )é

            if (data_index_key_cls())é
               ;
            è
            else return 0;
        è

        if ((equal_val("INDEX")))é

            if (data_index_by_cl())é
               ;
            è
            else return 0;
        è

    è

    printf("Rule recognized: data_occurs_cl çn");
    return 1;
è

int data_index_key_cls()é

    int ret=0;
    printf("Trying to match rule : data_index_key_cls çn");

    while ((equal_val("ASCENDING")) !!
           (equal_val("DESCENDING")))é

        if (data_index_key_cl())é
           ;
        è
        else return 0;

        ret = 1;

    è

    if(ret==1) printf("Rule recognized: data_index_key_cls çn");

    return ret;
è

int
data_index_key_cl()é

    printf("Trying to match rule : data_index_key_cl çn");

    if ((equal_val("ASCENDING")) !!
        (equal_val("DESCENDING")) )é

       consume();

       if ((equal_val("KEY")))é

          consume();
       è

       if ((equal_val("IS")))é

          consume();
       è

       if (id_names())é
          ;
       è
       else return 0;

    è
    else return 0;

    printf("Rule recognized: data_index_key_cl çn");
    return 1;
è

int
data_index_by_cl()é

    printf("Trying to match rule : data_index_by_cl çn");

    if (match_val("INDEX"))é
       ;
    è
    else return 0;

    if ((equal_val("BY")))é

       consume();
    è

    if (id_names())é
       ;
    è
    else return 0;


    printf("Rule recognized: data_index_by_cl çn");
    return 1;
è

/*------*/

int
data_pic_cl()é


    printf("Trying to match rule : data_pic_cl çn");

    save = set_context("data_pic_chars");

    if(match_val("PIC"))é
       ;
    è
    else if(match_val("PICTURE"))é
            ;
         è
    else return 0;


    if (data_pic_str())é
       ;
    è
    else return  0;

    restore_context(save);


    if (equal_val("SIZE"))é
       if (data_pic_size_local())é
          ;
       è
       else return  0;
    è


    /* consommer Space qui vient apres la fin de pic str */
    if (equal_type("SPACE"))é

       consume();
    è


    printf("Rule recognized: data_pic_cl çn");
    return 1;
è


int
data_pic_str()é


    printf("Trying to match rule : data_pic_str çn");


    if (equal_val("IS"))é

       consume();

    è

    /* Lexer/Parser Hack */
    /* pour ne pas accepter espace apres repeat : */
    /* PIC 9(9) V                                 */
    /* on consomme le premier espace apres pic et IS */
    /* et puis enlever les espaces de token picchar  */

    /* Space */

    if (match_type("SPACE"))é
       ;
    è
    else return  0;

    /* Currency */
    if (equal_val("$"))é

       consume();

    è

    while (equal_type("PICCHARS"))é

   /*  set_context("data_pic_chars");
   */
       /* PicChars */
       if (data_pic_chars())é
          ;
       è
       else return  0;

   /*  restore_context(save);
   */
       /* Repeat */
       if (equal_val("("))é

          if (data_pic_repeat())é
             ;
          è
          else return  0;

       è
    è


    printf("Rule recognized: data_pic_str çn");
    return 1;
è

/****/

int
data_pic_chars()é

    printf("Trying to match rule : data_pic_chars çn");

    if (match_type("PICCHARS"))é
       ;
    è
    else
    é
       return  0;
    è

    printf("Rule recognized: data_pic_chars çn");

    return 1;
è

int
data_pic_repeat()é

    printf("Trying to match rule : data_pic_repeat çn");


    if (match_val("("))é
       ;
    è
    else return  0;

    if ((equal_attr("UNSIGNED"))&&(equal_attr("INTEGER")))é
       consume();
    è
    else return  0;

    if (match_val(")"))é
       ;
    è
    else return  0;

    printf("Rule recognized: data_pic_repeat çn");
    return 1;
è


int
data_pic_size_local()é

    printf("Trying to match rule : data_pic_size_local çn");


    if (match_val("SIZE"))é
       ;
    è
    else return  0;

    if (equal_val("IS"))é

       consume();

    è

    if (match_attr("INTEGER"))é
       ;
    è
    else return  0;

    if (match_val("LOCALE"))é
       ;
    è
    else return  0;

    if (equal_val("IS"))é

       consume();

       if (mnemo_or_envir())é
          ;
       è
       else return  0;
    è

    else é
       if (equal_type("IDENTIFIER"))é
          if (mnemo_or_envir())é
             ;
          è
          else return  0;
       è
    è

    printf("Rule recognized: data_pic_size_local çn");
    return 1;
è

/*------*/

int
data_sign_cl()é

    printf("Trying to match rule : data_sign_cl çn");

    if (equal_val("SIGN"))é

       consume();

       if (equal_val("IS"))é

          consume();

       è

    è

    if (equal_val("LEADING"))é

       consume();

    è
    else if(equal_val("TRAILING"))é

             consume();
         è

    else return 0;

    if (equal_val("SEPARATE"))é

       consume();

       if (equal_val("CHARACTER"))é

          consume();

       è

    è


    printf("Rule recognized: data_sign_cl çn");
    return 1;
è

/*------*/

int
data_value_cl()é

    printf("Trying to match rule : data_value_cl çn");


    if (match_val("VALUE"))é
       ;
    è
    else return  0;

    if (equal_val("IS"))é

       consume();

    è

    if (litr())é
       ;
    è
    else return  0;


    printf("Rule recognized: data_value_cl çn");
    return 1;
è

/*------*/

int
data_sync_cl()é

    printf("Trying to match rule : data_sync_cl çn");

    if ((equal_val("SYNC"))) é

       consume();

    è
    else if (equal_val("SYNCHRONIZED"))é

       consume();
    è
    else return 0;

    if ((equal_val("LEFT"))) é

       consume();
    è
    else if (equal_val("RIGHT")) é

       consume();

    è

    printf("Rule recognized: data_sync_cl çn");
    return 1;
è

/*------*/

int
data_usage_cl()é

    printf("Trying to match rule : data_usage_cl çn");

    if (equal_val("USAGE"))é

       consume();

       if (equal_val("IS"))é

          consume();

       è

    è

    if (equal_val("BINARY"))é

        consume();


    è else if (equal_val("COMPUTATIONAL"))é

        consume();

    è else if (equal_val("COMP"))é

        consume();

    è else if (equal_val("COMPUTATIONAL-1"))é

        consume();

    è else if (equal_val("COMP-1"))é

        consume();

    è else if (equal_val("COMPUTATIONAL-2"))é

        consume();

    è else if (equal_val("COMP-2"))é

        consume();

    è else if (equal_val("COMPUTATIONAL-3"))é

        consume();

    è else if (equal_val("COMP-3"))é

        consume();

    è else if (equal_val("COMPUTATIONAL-4"))é

        consume();

    è else if (equal_val("COMP-4"))é

        consume();

    è else if (equal_val("DISPLAY"))é

        consume();

    è else if (equal_val("DISPLAY-1"))é

        consume();

    è else if (equal_val("INDEX"))é

        consume();

    è else if (equal_val("PACKED-DECIMAL"))é

        consume();

    è else if (equal_val("POINTER"))é

        consume();

    è else if (equal_val("PROCEDURE-POINTER"))é

        consume();

    è else return 0;

    printf("Rule recognized: data_usage_cl çn");
    return 1;
è
/*---------------------- renames and conditional function -----------*/

int
renames_cl()
é
    printf("Trying to match rule : renames_cl çn");

    if (match_val("RENAMES"))é
        ;
    è
    else return  0;

    if (id_name_qualif())é
        ;
    è
    else return  0;

    if ((equal_val("THROUGH")) !!
        (equal_val("THRU")) )é

       consume();

       if (id_name_qualif())é
           ;
       è
       else return  0;

    è

    printf("Rule recognized: renames_cl çn");
    return 1;
è

int
cond_val_cl()
é
    printf("Trying to match rule : cond_val_cl çn");

    int ret =0;

    if      (match_val("VALUE"))é
         if (match_val("IS"))é
            ;
         è
    è
    else if (match_val("VALUES"))é
         if (match_val("ARE"))é
            ;
         è
    è
    else return  0;

    while (litr())é

       if ((equal_val("THROUGH")) !!
           (equal_val("THRU")) )é

           consume();

          if (litr())é
              ;
          è
          else return  0;

       è
    è

    printf("Rule recognized: cond_val_cl çn");
    return 1;
è

/*---------------------- Context function    ------------------------*/

int
affich_context()é

   printf("çn");
   printf("context.division : <%s>çn", _context.division);
   printf("context.section  : <%s>çn", _context.section );
   printf("context.sentence : <%s>çn", _context.sentence);
   printf("context.clause   : <%s>çn", _context.clause  );
   printf("context.keyword  : <%s>çn", _context.keyword );
   printf("context.other    : <%s>çn", _context.other   );
   printf("çn");

   return 1;
è

context
set_context(char* clause)é

    context save;

    if(strcmp("data_pic_chars",clause)==0)é

       save = _context;
       _context.division ="DATA";
       _context.section  ="";
       _context.clause   ="data_pic_chars";
       _context.keyword  ="PIC";
       _context.other    ="";

    è

    affich_context();

    return  save;

è

int
restore_context(context save)é

    _context = save;

    affich_context();

    return  1;

è

/*---------------------- Functions for permutation -----------------*/
fp_t_nod*
alim_clauses()é

    printf("alim_clauses : Start çn");

    fp_t clauses_arrÝMAX_FP_ARR~;
    fp_t_nod* head;

    int i=0;

    fp_t_nod* node;
    node  = malloc (sizeof (fp_t_nod));

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 1;
    clauses_arrÝi~.fp = data_external_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "EXTERNAL";
  /*printf("alim_clauses : alimentation of cond_1 çn");
  */clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : Succesful insertion of clause  1 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    head           = node;
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 2;
    clauses_arrÝi~.fp = data_blankzero_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "BLANK";
  /*printf("alim_clauses : alimentation of cond_1 çn");
  */clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : Succesful insertion of clause  2 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 3;
    clauses_arrÝi~.fp = data_global_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "GLOBAL";
  /*printf("alim_clauses : alimentation of cond_1 çn");
  */clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : Succesful insertion of clause  3 çn");
    /**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 4;
    clauses_arrÝi~.fp = data_just_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "JUST";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ1~ = "JUSTIFIED";
    clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : alimentation of cond_1 çn");
    printf("alim_clauses : Succesful insertion of clause  4 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 5;
    clauses_arrÝi~.fp = data_occurs_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "OCCURS";
  /*printf("alim_clauses : alimentation of cond_1 çn");
  */clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : Succesful insertion of clause  5 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;


    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 6;
    clauses_arrÝi~.fp = data_pic_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "PIC";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ1~ = "PICTURE";
    clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : alimentation of cond_1 çn");
    printf("alim_clauses : Succesful insertion of clause  6 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 7;
    clauses_arrÝi~.fp = data_sign_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "SIGN";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ1~ = "LEADING";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ2~ = "TRAILING";
    clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : alimentation of cond_1 çn");
    printf("alim_clauses : Succesful insertion of clause  7 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 8;
    clauses_arrÝi~.fp = data_value_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "VALUE";
    clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : alimentation of cond_1 çn");
    printf("alim_clauses : Succesful insertion of clause  8 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 9;
    clauses_arrÝi~.fp = data_value_cl;
    clauses_arrÝi~.cond_1.arrÝ0~ = "SYNC";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ1~ = "SYNCHRONIZED";
    clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : alimentation of cond_1 çn");
    printf("alim_clauses : Succesful insertion of clause  9 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = malloc (sizeof (fp_t_nod));
    node           = node->next;
    /**/
    i++;

    clauses_arrÝi~.cond_1.len =0;
    clauses_arrÝi~.cond_2.len =0;
    clauses_arrÝi~.cond_1.arrÝ0~ = "";
    clauses_arrÝi~.cond_2.arrÝ0~ = "";

    clauses_arrÝi~.id = 10;
    clauses_arrÝi~.fp = data_usage_cl;
    clauses_arrÝi~.cond_1.arrÝ0~  = "USAGE";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ1~  = "BINARY";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ2~  = "COMPUTATIONAL";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ3~  = "COMP";;
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ4~  = "COMPUTATIONAL-1";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ5~  = "COMP-1";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ6~  = "COMPUTATIONAL-2";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ7~  = "COMP-2";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ8~  = "COMPUTATIONAL-3";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ9~  = "COMP-3";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ10~ = "COMPUTATIONAL-4";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ11~ = "COMP-4";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ12~ = "DISPLAY";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ13~ = "DISPLAY-1";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ14~ = "INDEX";;
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ15~ = "PACKED-DECIMAL";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ16~ = "POINTER";
    clauses_arrÝi~.cond_1.len++;
    clauses_arrÝi~.cond_1.arrÝ17~ = "PROCEDURE-POINTER";
    clauses_arrÝi~.cond_1.len++;
  /*printf("alim_clauses : alimentation of cond_1 çn");
    printf("alim_clauses : Succesful insertion of clause 10 çn");
  *//**/
    node->val      = clauses_arrÝi~;
    node->next     = NULL;
    /**/
    i++;

    /*--------------------------------------------------*/
    /*                                                  */
    /*--------------------------------------------------*/
    /*
    printf("Start for linked list building from array ...(%d)çn",i);

    fp_t_nod* temp;

    fp_t_nod* node = malloc (sizeof (fp_t_nod));
    node->val      = clauses_arrÝ0~;
    clauses = node;

    temp = clauses->next;

    for(j=1;j<i;j++)é

       printf("iteration (%d) çn",j+1);
       if (temp == NULL) é
          temp = malloc (sizeof (fp_t_nod));
          printf("malloc done çn");
       è

       temp->val  = clauses_arrÝj~;
       temp->next = NULL;

       clause_print(temp->val,"temp->val");


       clause_nod_print(temp,"temp->val");
       temp = temp->next;

       printf("Creation done çn");

    è
    */
    return head;

è
/*
int alim_clause_arr(fp_t_arr clauses)é

    printf("alim_clause_arr : Start çn");

    int i=0;
    int j=0;

    if (clause_arr == NULL) é
       clause_arr = malloc(MAX_FUNCTIONS*sizeof(fp_t));
       printf("alim_clause_arr : allocation of MAX_FUNCTIONS size çn");
       for(i=0;i<MAX_FUNCTIONS;i++)é
          (clause_arr+i)->cond_1 = malloc(MAX_COND*sizeof(char*));
          (clause_arr+i)->cond_2 = malloc(MAX_COND*sizeof(char*));
       è
    è
    printf("alim_clause_arr : allocation of MAX_COND size çn");
    printf("sizeof(clause_arr) malloc : (%d) çn",sizeof(*clause_arr));

    i = 0;
    j = 0;

    (clause_arr+i)->id = 1;
    (clause_arr+i)->fp = data_external_cl;
    *(((clause_arr+i)->cond_1)+j) = "IS"; j++;
    printf("alim_clause_arr : alimentation of cond_1 çn");
    realloc((clause_arr+i)->cond_1,j*sizeof(char*)); j=0;
    printf("alim_clause_arr : allocation of j size for cond_1 çn");
    *(((clause_arr+i)->cond_2)+j) = "EXTERNAL"; j++;
    printf("alim_clause_arr : alimentation of cond_2 çn");
    realloc((clause_arr+i)->cond_2,j*sizeof(char*)); j=0;
    printf("alim_clause_arr : allocation of j size for cond_2 çn");
    i++;
    printf("alim_clause_arr : Succesful insertion of clause  1 çn");

    (clause_arr+i)->id = 2;
    (clause_arr+i)->fp = data_external_cl;
    *(((clause_arr+i)->cond_1)+j) = "BLANK"; j=0;
    realloc((clause_arr+i)->cond_1,j*sizeof(char*)); j=0;
    realloc((clause_arr+i)->cond_2,j*sizeof(char*)); j=0;
    i++;
    printf("alim_clause_arr : Succesful insertion of clause  2 çn");

    (clause_arr+i)->id = 3;
    (clause_arr+i)->fp = data_global_cl;
    *(((clause_arr+i)->cond_1)+j) = "IS"; j++;
    realloc((clause_arr+i)->cond_1,j*sizeof(char*)); j=0;
    *(((clause_arr+i)->cond_2)+j) = "GLOBAL"; j++;
    realloc((clause_arr+i)->cond_2,j*sizeof(char*)); j=0;
    i++;
    printf("alim_clause_arr : Succesful insertion of clause  3 çn");

    (clause_arr+i)->id = 4;
    (clause_arr+i)->fp = data_just_cl;
    *(((clause_arr+i)->cond_1)+j) = "JUST"; j++;
    *(((clause_arr+i)->cond_1)+j) = "JUSTIFIED"; j++;
    realloc((clause_arr+i)->cond_1,j*sizeof(char*)); j=0;
    *(((clause_arr+i)->cond_2)+j) = "GLOBAL"; j++;
    realloc((clause_arr+i)->cond_2,j*sizeof(char*)); j=0;
    i++;
    printf("alim_clause_arr : Succesful insertion of clause  4 çn");

    (clause_arr+i)->id = 5;
    (clause_arr+i)->fp = data_occurs_cl;
    *(((clause_arr+i)->cond_1)+j) = "OCCURS"; j++;
    realloc((clause_arr+i)->cond_1,j*sizeof(char*)); j=0;
    realloc((clause_arr+i)->cond_2,j*sizeof(char*)); j=0;
    i++;
    printf("alim_clause_arr : Succesful insertion of clause  5 çn");

    fp_t *temp = realloc(clause_arr,i*sizeof(fp_t));

    if (temp == NULL)é
       printf("Error allocating memory!çn");
       return 0;
    è
    else é
       clause_arr = temp;
       printf("Succesful reallocation!çn");
    printf("sizeof(clause_arr) realloc : (%d) çn",sizeof(*clause_arr));
    è
    return 1;

è
*/

int
tkn_in_array (str_arr conditions)é

   int i;

 /*printf("tkn_in_array: conditions.len = (%d) çn",conditions.len);
 */
   for(i=0;i<conditions.len;i++)é

      printf("tkn_in_array: conditions.arr:(%s) çn",conditions.arrÝi~);
      if (equal_val(conditions.arrÝi~)) é
         printf("tkn_in_array: lookahead found(%s) çn",
                conditions.arrÝi~);
         return 1;
      è
   è

   return 0;
è

fp_t_nod*
delete_clauses(fp_t_nod* clauses,fp_t_nod* to_delete)é

   printf("delete_clauses: clauses = (%d) to_delete(%d) çn",
                           clauses ,      to_delete);
   fp_t_nod* temp;

   /* list is empty */
   if(clauses == NULL) é
     printf("delete_clauses : List is empty no destroying to do. çn");
     return clauses;

   è

   /* node to delete is the head of list */
   if(clauses == to_delete) é
     printf("delete_clauses : Beheading the List >:) ... çn");
     temp = clauses->next;
     free(clauses);
     return temp;
   è


   /* when other */
   /* tout pointer vers head of list */
   temp = clauses;
   fp_t_nod* beforeTemp = clauses;

   /* refaire tant qu'on est pas à null (fin liste) */
   while (temp §= NULL)é

      /* si adresse d'element a supprimer trouver */
      if(temp == to_delete)é
         printf("delete_clauses : node found, destroying ... çn");
         /* pointer le next du maillon d'avant vers celui d'apres */
         /* c-a-d : skip temp */
         beforeTemp->next = temp->next;
         /* liberer element a supprimer */
         free(temp);
         return clauses;
      è

      beforeTemp = temp;
      temp = temp->next;


   è
è

int
clause_print(fp_t clause,char* txt)é

    int i = 0;
    txt ="";
    printf("clause.id           :(%d)çn",clause.id);
    printf("clause.cond_1.len   :(%d)çn",clause.cond_1.len);
    for(i=0;i<clause.cond_1.len;i++)
       printf("clause.cond_1.arr(%d):(%s)çn",i,clause.cond_1.arrÝi~);
    printf("clause.cond_2.len   :(%d)çn",clause.cond_2.len);
    for(i=0;i<clause.cond_2.len;i++)
       printf("clause.cond_2.arr(%d):(%s)çn",i,clause.cond_2.arrÝi~);

    return 1;
è

int
clause_nod_print(fp_t_nod* clause_nod,char* txt)é

    printf("*************************************çn");
    printf("* Current * clause_nod       (%d) ***çn",clause_nod);
    printf("* Next    * clause_nod->next (%d) ***çn",clause_nod->next);
    clause_print(clause_nod->val,txt);
    printf("*************************************çn");

    return 1;
è

int
print_clauses(fp_t_nod* clauses)é

    printf("printf_clauses Start...çnçn");

    fp_t_nod *iterator = clauses;

    do é

       clause_nod_print(iterator,"");
       iterator = iterator->next;
    /* assert(iterator == NULL); */

    è
    while (iterator §= NULL);

    printf("printf_clauses End.çn");
    return 1;
è

/*---------------------- Build AST from attr ------------------------*/

ast*
build_literal(int bool_all)é

    ast* ret=NULL;

    int   bool_numeric      =0;
    int   bool_alphanumeric =0;
    int   bool_hexadecimal  =0;
    int   bool_positive     =0;
    int   bool_negative     =0;
    int   bool_unsigned     =0;
    int   bool_singl_q      =0;
    int   bool_doubl_q      =0;
    int   bool_intgr        =0;
    int   bool_decim        =0;
    int   bool_figurative   =0;
    int   char_length       =0;
    char* value;

    if(equal_attr("NUMERIC"))          bool_numeric      =1;
    if(equal_attr("ALPHANUMERIC"))     bool_alphanumeric =1;
    if(equal_attr("HEX"))              bool_hexadecimal  =1;
    if(equal_attr("POSITIVE"))         bool_positive     =1;
    if(equal_attr("NEGATIVE"))         bool_negative     =1;
    if(equal_attr("UNSIGNED"))         bool_unsigned     =1;
    if(equal_attr("SINGLE QUOTE"))     bool_singl_q      =1;
    if(equal_attr("DOUBLE QUOTE"))     bool_doubl_q      =1;
    if(equal_attr("INTEGER"))          bool_intgr        =1;
    if(equal_attr("DECIMAL"))          bool_decim        =1;
    if(equal_attr("FIGURATIVE CONST")) bool_figurative   =1;

    char_length = get_token_len();
    value       = get_token_val();
    /*value    = "Hard-coded value";*/
    /*strcpy(value,get_token_val());*/

    ret=make_literal(value,bool_all, bool_numeric, bool_alphanumeric,
                     bool_hexadecimal, bool_positive,
                     bool_negative, bool_unsigned,
                     bool_singl_q, bool_doubl_q,
                     bool_intgr, bool_decim,
                     bool_figurative,
                     char_length);

    printf("built literal (%s) address(%d) char_len(%d)çn"
                                     ,ret->node.literal.value
                                     ,ret
                                     ,ret->node.literal.char_length);
    return ret;
è

/*---------------------- Auxiliary functions ------------------------*/
int
equal_type(char* expected)é

    printf("equal_type (%s) ?? ",expected);
    if ((strcasecmp(lookahead.tkn_type,       expected) == 0 ))é
        printf("TRUE çn");
        return 1;
    è
    else é
        printf("FALSE çn");
        return 0;
    è
è
/*----*/
int
equal_val(char* expected)é

    printf("equal_val (%s) ?? ",expected);
    if ((strcasecmp(lookahead.tkn_val,        expected) == 0 )) é
        printf("TRUE çn");
        return 1;
    è

    else é
        printf("FALSE çn");
        return 0;
    è
è
/*----*/
int
equal_attr(char* expected)é


    int i;

    printf("equal_attr (%s) ?? ",expected);
    for(i=0;i<lookahead.tkn_attr_len;i++)é

       if (strcasecmp(lookahead.tkn_attrÝi~, expected) == 0)é
          printf("TRUE çn");
          return 1;
       è
    è

    printf("FALSE çn");
    return 0;
è
/*----*/
int
match_type(char* expected)é

    printf("match_type : Trying to match type  : <%s> çn", expected);

    if (equal_type(expected)) é
        consume();
        return 1;
    è
    else
        return 0;
è
/*----*/
int
match_val (char* expected)é

    printf("match_val  : Trying to match Value : <%s> çn", expected);

    if (equal_val(expected)) é
        consume();
        return 1;
    è
    else
        return 0;
è
/*----*/
int
match_attr(char* expected)é

    printf("match_attr : Trying to match Attr  : <%s> çn", expected);

    if (equal_attr(expected)) é
        consume();
        return 1;
    è
    else
        return 0;
è
/*----*/
int
consume()é

    printf("consume(%s). çn",lookahead.tkn_val);
    printf("1 bug tracker : global_ret (%s) (%d)çn",
                                  global_ret->node.literal.value,
                                  global_ret);
    lookahead = getNextToken();
    printf("2 bug tracker : global_ret (%s) (%d)çn",
                                  global_ret->node.literal.value,
                                  global_ret);

    return 1;
è
/*----*/
int
error(char* msg )é

    printf("error : %s",msg);
    exit(EXIT_FAILURE);

è

/*----*/

int
match(char* terminal)é
    printf("match()    : Trying to match token : <%s> çn",terminal);

    /*
    if    ((strcasecmp(lookahead.tkn_val,  "ZERO") == 0 )
        && (strcasecmp(lookahead.tkn_type, "ZERO") == 0 )
        && (strcasecmp(lookahead.tkn_type2,"ZERO") == 0 ) )
    é
        printf("match()    : Lookahead ZERO, Get next token");
        lookahead = getNextToken();

    è  */

    if    ((strcasecmp(lookahead.tkn_val,     terminal) == 0 )
        !! (strcasecmp(lookahead.tkn_type,    terminal) == 0 )
        !! (strcasecmp(lookahead.tkn_attrÝ0~, terminal) == 0 )
        !! (strcasecmp(lookahead.tkn_attrÝ1~, terminal) == 0 ))
    é
        printf("match()    : Token recognized : %s çn",terminal);
    /* mettre lookahead a zero en attendant le chargement de context */
    /*  lookahead.tkn_val    = "ZERO";
        lookahead.tkn_type   = "ZERO";
        lookahead.tkn_type2  = "ZERO"; */

        lookahead = getNextToken();

    è
    else
    é
        printf("match()    : Syntax error expected %s found<%s><%s>çn",
		      terminal, lookahead.tkn_type,lookahead.tkn_val);
        return 0;
    è
    return 1;
è

/*------*/

int
tknEqual(char* expected)é
/*  printf("tknEqual() : is Current token equal to:<%s>? çn",expected);
*/ /*
    if    ((strcasecmp(lookahead.tkn_val,  "ZERO") == 0 )
        && (strcasecmp(lookahead.tkn_type, "ZERO") == 0 )
        && (strcasecmp(lookahead.tkn_type2,"ZERO") == 0 ) )
    é
        printf("match()    : Lookahead ZERO, Get next token");
        lookahead = getNextToken();

    è
    */
    if ((strcasecmp(lookahead.tkn_val,        expected) == 0 )
        !! (strcasecmp(lookahead.tkn_type,    expected) == 0 )
        !! (strcasecmp(lookahead.tkn_attrÝ0~, expected) == 0 )
        !! (strcasecmp(lookahead.tkn_attrÝ1~, expected) == 0 ) )
    é
        printf("tknEqual() : Current token == to <%s> çn",expected);
        return 1;

    è
    else
    é
    /*  printf("tknEqual() : Current token != to <%s> çn",expected);*/
        return 0;
    è

è
/*------------------------- Auxiliary functions ---------------------*/

char*
get_token_val()é
    return lookahead.tkn_val;
è

char*
get_token_type()é
    return lookahead.tkn_type;
è
int
get_token_len()é
    return lookahead.tkn_len;
è

£include <stdio.h>
£include <stdlib.h>

£include "Lexerh"
£include "tokenzrh"

int i = 0;
ast* global_ret;

/* curr_ln_obj stores the actual string to tokenize */
static ln_obj curr_ln_obj;

token getNextToken()é

    printf("3 bug tracker global_ret (%s) address(%d) char_len(%d)"ç
           "  single quote (%d) alphanumeric (%d)"
                       ,global_ret->node.literal.value
                       ,global_ret
                       ,global_ret->node.literal.char_length
                       ,global_ret->node.literal.bool_singl_q
                       ,global_ret->node.literal.bool_alphanumeric);
    /* made static to preserve value after recursive call */
    static token _ret;
    ln_str_num next_ln;
    /*
    printf("getNextToken() : ");
    printf("curr_ln_num:(%d)curr_ln_obj.ln_8_72:<%s>çn",
            curr_ln_num,curr_ln_obj.ln_8_72);
    */
    /* still chars in curr_ln_obj.ln_8_72 ? */
    while(strlen(curr_ln_obj.ln_8_72)<1) é

       /* get next Line           */
       next_ln = getLineString(curr_ln_num);

       /* if  Line num = 0 end program  */
       if (next_ln.ln_num == 0 ) é

           printf("getNextToken() : ");
           printf(" *********** PROGRAM END ***********çn");
          _ret.tkn_type = "PROGRAM$";
          _ret.tkn_val  = ""        ;
          return _ret;

       è

       /* increment current line  */
       curr_ln_num++;

       /* call preprocessor to prepare line */
       curr_ln_obj = preprocessor(next_ln);
    /*
       printf("getNextToken() : ");
       printf("ln_8_72 length : (%d)çn",strlen(curr_ln_obj.ln_8_72));
    */
    è

    printf("5 bug tracker global_ret (%s) address(%d) char_len(%d)"ç
           "  single quote (%d) alphanumeric (%d)"
                       ,global_ret->node.literal.value
                       ,global_ret
                       ,global_ret->node.literal.char_length
                       ,global_ret->node.literal.bool_singl_q
                       ,global_ret->node.literal.bool_alphanumeric);
    /* call tokenizer to get token */
    _ret = tokenizer(curr_ln_obj.ln_8_72);
    _ret.tkn_lnnum =curr_ln_obj.ln_num;


    /*
    printf("getNextToken() : ");
    printf("tkn_lnnum      : (%d)çn",_ret.tkn_lnnum);
    */

    /* do not let ENDLine token escalde to parser */
    /* Recursive !!! */
    if (strcmp(_ret.tkn_type,"ENDLINE")==0) é
        printf("getNextToken() : getting recursive ! çn");
        getNextToken();
    è

    /* If Token = ERROR ERROR and lde to parser */
    /* Recursive !!! */
    /*
    if ((strcmp(_ret.tkn_type,"ERROR")==0) && (next_ln.ln_str=="$"))é
        printf("getNextToken() : ERROR & $ => PROGRAM$ çn");
        _ret.tkn_type="PROGRAM$";
        _ret.tkn_val="PROGRAM$";
        getNextToken();
    è
    */
    printf("4 bug tracker global_ret (%s) address(%d) char_len(%d)"ç
           "  single quote (%d) alphanumeric (%d)"
                       ,global_ret->node.literal.value
                       ,global_ret
                       ,global_ret->node.literal.char_length
                       ,global_ret->node.literal.bool_singl_q
                       ,global_ret->node.literal.bool_alphanumeric);
    return _ret;

è

ln_str_num getLineString (int linenum) é

    ln_str_num _ret;

    /* if current line num > num of last line return $ */
    if(linenum > lnumlast)é

     /*_ret.ln_str = "PROGRAM$"; */
       _ret.ln_num = 0;

    è
    else
    é
       if(linenum < 1)é

     /*   _ret.ln_str = "^";  */
          _ret.ln_num = 0;

       è
       else
       é
           /* else return line from rawcode and line number   */
           _ret.ln_str = rawcodeÝlinenum-1~;
           _ret.ln_num = linenum;
       è

    è
    /*
    printf ("getLineString() : ");
    printf ("num:(%d)str:<%s>çn",_ret.ln_num,_ret.ln_str);
    */
    return _ret;

è

ln_obj preprocessor(ln_str_num lnstrnum)é

    ln_obj _ret=é"","","","",0,0è;
    int i=0;
    /*
    if ((strcmp(lnstrnum.ln_str,"PROGRAM$")==0)) é
        *(_ret.ln_8_72)='$';
        *(_ret.ln_8_72+1)='ç0';
        return _ret;
    è
    */
    if (strlen(lnstrnum.ln_str)==80)é

       strncpy(_ret.ln_1_6,lnstrnum.ln_str,6);
       *(_ret.ln_1_6+6) = 'ç0';
       strncpy(_ret.ln_7,lnstrnum.ln_str+6,1);
       *(_ret.ln_7+1) = 'ç0';
       strncpy(_ret.ln_8_72,lnstrnum.ln_str+7,65);
       *(_ret.ln_8_72+65) = 'ç0';
       strncpy(_ret.ln_73_80,lnstrnum.ln_str+72,8);
       *(_ret.ln_73_80+8) = 'ç0';

       while (isspace(*(_ret.ln_8_72 + i))) i++;

       _ret.ln_indent= i+1;
       _ret.ln_num=lnstrnum.ln_num;


    è
    /*
    printf("preprocessor() : ");
    printf("ln_1_6<%s>ln_7<%s>çn",_ret.ln_1_6,_ret.ln_7);

    printf("preprocessor() : ");
    printf("ln_8_72<%s>ln_73_80<%s>çn",_ret.ln_8_72,_ret.ln_73_80);
    printf("preprocessor() : ");
    printf("ln_indent(%d)ln_num(%d)çn",_ret.ln_indent,_ret.ln_num);
    */
    /* '*' = 92 */
    /* '-' = 96 */
    /* '/' = 97 */

    if (((*(_ret.ln_7))==92) !! ((*(_ret.ln_7))==97)) é
        printf ("preprocessor()1: Comment line (%d)çn",_ret.ln_num);
        printf ("preprocessor()2:_ret.ln_8_72 <%s>çn",_ret.ln_8_72);
    /*  sprintf(_ret.ln_8_72,"%-65s"); */
        *(_ret.ln_8_72)='ç0';
        printf ("preprocessor()3:_ret.ln_8_72 <%s>çn",_ret.ln_8_72);
        printf ("preprocessor()4: len ln_8_72 (%d)çn",
               strlen(_ret.ln_8_72));
        return _ret;
    è

    if ((*(_ret.ln_7))==96)  é
        printf ("preprocessor()5: Continuation not supported yet");
        printf ("(%d)çn",_ret.ln_num);
        *(_ret.ln_8_72)='$';
        *(_ret.ln_8_72+1)='ç0';
        return _ret;
    è

    if (_ret.ln_indent == 66) é
        printf ("preprocessor()6: Empty Line   (%d)çn",_ret.ln_num);
        *(_ret.ln_8_72)='ç0';
        return _ret;
    è

    return _ret;

è

token peekNextToken()é

    return getNextToken();
è

£include <stdio.h>
£include <stdlib.h>
£include <string.h>

£include "Rexxcomh"

       int    argc;                 /* nombre d'arguments  */
       int    cursl;                /* position ligne   de cursor */
       int    cursc;                /* position colonne de cursor */
       char   rawcodeÝ20000~Ý81~;   /* code Cobol brute           */
       int    lnumlast;             /* numero de la dernière ligne*/
       char*  mainret;              /* zone retour                */

       int    curr_ln_num;          /* current line being parsed  */

/* bug connu : rawcode depasse le code reel par 14 car à la fin */
int getArgsRexx() é

       int    i=0;
       int    rawCode_length=0;
       int    rawCode_mod_80=0;
       int    rawCode_div_80=0;
       /*
       printf("first arg        : %s çn",        __osplistÝ0~) ;
       printf("strcmp           : %d çn", strcmp(__osplistÝ0~,""));
       printf("first arg to int : %d çn",   atoi(__osplistÝ0~));
       */
       if ((strcmp(__osplistÝ0~,"")) && (atoi(__osplistÝ0~) > 0)) é
          argc = atoi(__osplistÝ0~);
          printf("getArgsRexx() : ");
          printf("argc          : (%d) çn", argc);
       è
       else é
          printf("getArgsRexx() : ");
          printf("Required argument argc not found or not numeric çn");

          return -1;
       è

       if ((strcmp(__osplistÝ1~,"")) && (atoi(__osplistÝ1~) > 0)) é
          cursc = atoi(__osplistÝ1~);
          printf("getArgsRexx() : ");
          printf("cursc         : (%d) çn", cursc);
       è
       else é
          printf("getArgsRexx() : ");
          printf("Required argument cursc not found or not numericçn");
          return -1;
       è

       if ((strcmp(__osplistÝ2~,"")) && (atoi(__osplistÝ2~) > 0)) é
          cursl = atoi(__osplistÝ2~);
          printf("getArgsRexx() : ");
          printf("cursl         : (%d) çn", cursl);
          /* current line number to increment on each read */
          curr_ln_num = cursl;
       è
       else é
          printf("getArgsRexx() : ");
          printf("Required argument cursl not found or not numericçn");
          return -1;
       è


       if ((strcmp(__osplistÝ4~,"")) && (atoi(__osplistÝ4~) > 0)) é
          lnumlast = atoi(__osplistÝ4~);
          printf("getArgsRexx() : ");
          printf("lnumlast      : (%d) çn", lnumlast);
       è
       else é
          printf("getArgsRexx() : ");
       printf("Required argument lnumlast not found or not numericçn");
          return -1;
       è

       rawCode_length = strlen(__osplistÝ3~);
       rawCode_mod_80 = strlen(__osplistÝ3~)%80;
       rawCode_div_80 = strlen(__osplistÝ3~)/80;

       printf("getArgsRexx() : ");
       printf("rawcode length : (%d) çn", rawCode_length);
       printf("getArgsRexx() : ");
       printf("modulo 80      : (%d) çn", rawCode_mod_80);
       printf("getArgsRexx() : ");
       printf("divide by 80   : (%d) çn", rawCode_div_80);
       /*
       printf("<%.*s>çn",80 + rawCode_mod_80,
              __osplistÝ3~+(rawCode_length-(80+rawCode_mod_80)));
       */
       if (rawCode_div_80 §= lnumlast ) é

          printf("getArgsRexx() : ");
          printf("lnumlast is not equal to rawCode_div_80çn");
          return -1;
       è

       if ((rawCode_length       > 0 )
    /* && ((strlen(__osplistÝ3~) % 80) == 0) */
       && ((rawCode_div_80           ) <= 20000)) é

          for (i=0;i<(strlen(__osplistÝ3~)/80);i++) é

          strncpy(rawcodeÝi~,__osplistÝ3~+(80*i),80);
          rawcodeÝi~Ý80~ = 'ç0';
          è

       è
       else é
          printf("getArgsRexx() : ");
          printf("Required argument rawcode invalid çn");
          return -1;
       è
       /*
       printf ("i :   %d çn", i );
       int j;
       for (j=0;j<i;j=j+1000) é

          printf("%sçn",rawcodeÝj~);
       è
       */

è

£include <regex.h>
£include <stdio.h>
£include <stdlib.h>
£include <string.h>

£include "tokenzrh"

£define NB_MATCH_MAX     7
£define NB_REGEX_MAX    30

  /*---------------------------------------------------------------*/
  /* FTA1: modulariser le code : regex, communication avec REXX    */
  /*       reduction du string , creation de la liste des tokens   */
  /*---------------------------------------------------------------*/
  /* la reduction du string enleve le separteur de debut           */
  /* (espace, virgule mais pas ' pour string )                     */
  /*---------------------------------------------------------------*/
  /* L'ordre de check des REgex semblables est :                   */
  /* -Keyword avant identifier, c ce qui en fait des mots reserves */
  /* -Dernier regex est : Espace puis enfin Erreur.                */
  /* -hexa literal avant identifier                                */
  /* exemple : x'ff'=> hex literal                                 */
  /* exemple : A'ff'=> identifier + string literal                 */
  /* -Choisir le match le plus long                                */
  /* exemple : **   => exponent au lieu de multiply                */
  /*           2,2  => decimal au lieu de integer                  */
  /*           a-b  => identifier a au lieu de a - b               */
  /*           a+b  => a + b                                       */
  /*---------------------------------------------------------------*/


token tokenizer(char* ln_8_72)
é
    token _ret = é0,0,0,"ERROR","ERROR"è;

    static int reduction_len;

    /* Regex for token type         */
    regex_t    pregIdent;
    regex_t    pregPicChars;
    regex_t    pregLiterNum;
    regex_t    pregLiterQuot;
    regex_t    pregKeywoAll;
    regex_t    pregSymbols;
    regex_t    pregEndLine;
    regex_t    pregSpace;

    /* Regex for token attributes   */
    regex_t    pregSpclReg;
    regex_t    pregFgrtvConst;
    regex_t    pregNumeric;
    regex_t    pregQuoted;
    regex_t    pregSQuoted;
    regex_t    pregDQuoted;
    regex_t    pregHex;
    regex_t    pregAlphanum;
    regex_t    pregIntgr;
    regex_t    pregDecim;
    regex_t    pregUnsigned;
    regex_t    pregPositive;
    regex_t    pregNegative;
    regex_t    pregLvlnum;
    regex_t    pregRelOp;
    regex_t    pregAritOp;

 /* regex_t    pregLiter1;
    regex_t    pregLiter2;
    regex_t    pregPerio;
    regex_t    pregLvl66;
    regex_t    pregLvl88;
    regex_t    pregHexL1;
    regex_t    pregHexL2;
    regex_t    pregLBrack;
    regex_t    pregRBrack;
    regex_t    pregPlus;
    regex_t    pregMinus;
    regex_t    pregExpon;
    regex_t    pregMultp;
    regex_t    pregDivid;
    regex_t    pregEqual;
    regex_t    pregColon;
    regex_t    pregDollar;
    regex_t    pregUintgr; */

  /*    _____________________________________________________
      _(                                                     )_
     =_                I D E N T I F I E R                    _=
       (_____________________________________________________)
                                                                  */

  /*----------------------------*/
  /* Pattern pour indentifier   */
  /*--------------------------------------------------------------*/
  /* - Séparateur début: aucan ou plusieurs espaces ou virgules   */
  /* - Corps : Un mot cobol composé de lettres et chiffres        */
  /*   ainsi que tiret et undersoce qui doivent pas apparaitre    */
  /*   au debut ou à a fin. doit contenir au moins une lettre     */
  /* - Séparateur fin  : point, espace, virgule, fin, quote ou "  */
  /*--------------------------------------------------------------*/

    char     *ptrnIdent = "^( !,)*"                                ç
   "((Ý0-9~+Ý-_~*)*Ý0-9~*ÝA-Za-z~ÝA-Za-z0-9~*(Ý-_~+ÝA-Za-z0-9~+)*)"ç
                          "(.*)";

  /*    _____________________________________________________
      _(                                                     )_
     =_            P I C T U R E  C H A R A C T E R           _=
       (_____________________________________________________)
                                                                  */

  /*-------------------------------------------*/
  /* FTA1: ponctuation                         */
  /* FTA2: CR et DB                            */
  /*--------------------------------------------------------------*/
  /* - picture-string =  currency? (picchar+ repeat?)+            */
  /*   currency       =  $                                        */
  /*   picchar        =  ÝABEGPSVXZabegpsvxz90ç+ç-ç*ç$~           */
  /*   repeat         =  "(" Ý0-9~+ ")"                           */
  /*--------------------------------------------------------------*/

    char     *ptrnPicChars = "(^"                              ç
                             "(ÝABEGPSVXZabegpsvxz90çç+çç-çç*çç$~+))"ç
                             "(( !,)*!çç()(.*)";


  /*    _____________________________________________________
      _(                                                     )_
     =_             L I T E R A L  N U M E R I C              _=
       (_____________________________________________________)
                                                                  */

  /*--------------------------------------------------------------*/
  /* - Séparateur début: Zero ou plusieurs : espaces ou virgules  */
  /* - Corps : Commence par le separateur de string quote ou "    */
  /*   puis zero ou une suite de caractères sauf separateur de    */
  /*   string ou un double separateur de string et finit par le   */
  /*   meme separateur de string                                  */
  /* - Séparateur fin  : point, espace, virgule, fin, quote ou "  */
  /*--------------------------------------------------------------*/
    char      *ptrnLiterNum = "^( !,)*("                          ç
                           "(Ýçç+çç-~?Ý0-9~*,Ý0-9~+)!"  /* -9,7 */ç
                           "(Ýçç+çç-~?Ý0-9~+)"         /* +987 */ç
                      /*    ")(Ý^'~!$)(.*)"; */                   ç
                           ")(.*)";                               ç
  /*    _____________________________________________________
      _(                                                     )_
     =_             L I T E R A L  Q U O T E                  _=
       (_____________________________________________________)
                                                                  */

    char      *ptrnLiterQuot = "^( !,)*("                         ç
                           "('(Ý^'~!'')*')!"            /*  '.' */ ç
                           "(ç"(Ý^ç"~!ç"ç")*ç")!"       /*  "." */ ç
                           "(ÝXx~Ý'~Ý0-9A-Fa-f~+Ý'~)!"  /* x'.' */ ç
                           "(ÝXx~Ýç"~Ý0-9A-Fa-f~+Ýç"~)" /* x"." */ ç
                      /*    ")(Ý^'~!$)(.*)"; */                    ç
                           ")(.*)";                                ç
  /*    _____________________________________________________
      _(                                                     )_
     =_                   K E Y W O R D                       _=
       (_____________________________________________________)
                                                                  */

    char       *ptrnKeywoAll = "^( !,)*("                          ç
    /*   A   */                                                    ç
    "ACCEPT!ALPHABETIC-LOWER!APPLY!"                               ç
    "ACCESS!ALPHABETIC-UPPER!ARE!"                                 ç
    "ADD!ALPHANUMERIC!AREA!"                                       ç
    "ALPHANUMERIC-EDITED!AREAS!ADDRESS!"                           ç
    "ADVANCING!ALSO!ASCENDING!"                                    ç
    "AFTER!ALTER!ASSIGN!"                                          ç
    "ALTERNATE!AT!ALL!"                                            ç
    "ALPHABET!AND!AUTHOR!"                                         ç
    "ALPHABETIC!ANY!"                                              ç
    /*   B   */                                                    ç
    "BASIS!BINARY!BOTTOM!"                                         ç
    "BEFORE!BLANK!BY!"                                             ç
    "BEGINNING!BLOCK!"                                             ç
    /*   C   */                                                    ç
    "CALL!COLUMN!COMPUTATIONAL-5!"                                 ç
    "CANCEL!COM-REG!COMPUTE!"                                      ç
    "CBL!COMMA!CONFIGURATION!"                                     ç
    "CD!COMMON!CONTAINS!"                                          ç
    "CF!COMMUNICATION!CONTENT!"                                    ç
    "CH!COMP!CONTINUE!"                                            ç
    "CHARACTER!COMP-1!CONTROL!"                                    ç
    "CHARACTERS!COMP-2!CONTROLS!"                                  ç
    "CLASS!COMP-3!CONVERTING!"                                     ç
    "CLASS-ID!COMP-4!COPY!"                                        ç
    "CLOCK-UNITS!COMP-5!CORR!"                                     ç
    "CLOSE!COMPUTATIONAL!CORRESPONDING!"                           ç
    "COBOL!COMPUTATIONAL-1!COUNT!"                                 ç
    "CODE!COMPUTATIONAL-2!CURRENCY!"                               ç
    "CODE-SET!COMPUTATIONAL-3!"                                    ç
    "COLLATING!COMPUTATIONAL-4!"                                   ç
    /*   D   */                                                    ç
    "DATA!DEBUG-SUB-1!DESTINATION!"                                ç
    "DATE-COMPILED!DEBUG-SUB-2!DETAIL!"                            ç
    "DATE-WRITTEN!DEBUG-SUB-3!DISPLAY!"                            ç
    "DAY!DEBUGGING!DISPLAY-1!"                                     ç
    "DAY-OF-WEEK!DECIMAL-POINT!DIVIDE!"                            ç
    "DBCS!DECLARATIVES!DIVISION!"                                  ç
    "DE!DELETE!DOWN!"                                              ç
    "DEBUG-CONTENTS!DELIMITED!DUPLICATES!"                         ç
    "DELIMITER!DYNAMIC!DEBUG-ITEM!"                                ç
    "DEPENDING!DEBUG-LINE!"                                        ç
    "DESCENDING!DEBUG-NAME!"                                       ç
    /*   E   */                                                    ç
    "EGCS!END-INVOKE!ENDING!"                                      ç
    "EGI!END-MULTIPLY!ENTER!"                                      ç
    "EJECT!END-OF-PAGE!ENTRY!"                                     ç
    "ELSE!END-PERFORM!ENVIRONMENT!"                                ç
    "EMI!END-READ!EOP!"                                            ç
    "ENABLE!END-RECEIVE!EQUAL!"                                    ç
    "END!END-RETURN!ERROR!"                                        ç
    "END-ADD!END-REWRITE!ESI!"                                     ç
    "END-CALL!END-SEARCH!EVALUATE!"                                ç
    "END-COMPUTE!END-START!EVERY!"                                 ç
    "END-DELETE!END-STRING!EXCEPTION!"                             ç
    "END-DIVIDE!END-SUBTRACT!EXIT!"                                ç
    "END-EVALUATE!END-UNSTRING!EXTEND!"                            ç
    "END-IF!END-WRITE!EXTERNAL!"                                   ç
    /*   F   */                                                    ç
    "FALSE!FILLER!FOR!"                                            ç
    "FD!FINAL!FROM!"                                               ç
    "FILE!FIRST!FUNCTION!"                                         ç
    "FILE-CONTROL!FOOTING!"                                        ç
    /*   G   */                                                    ç
                                                                   ç
    "GENERATE!GO!GROUP!"                                           ç
    "GIVING!GOBACK!"                                               ç
    "GLOBAL!GREATER!"                                              ç
    /*   H   */                                                    ç
                                                                   ç
    "HEADING!HIGH-VALUE!HIGH-VALUES!"                              ç
    /*   I   */                                                    ç
    "I-O!INDICATE!INSPECT!"                                        ç
    "I-O-CONTROL!INHERITS!INSTALLATION!"                           ç
    "ID!INITIAL!INTO!"                                             ç
    "IDENTIFICATION!INITIALIZE!INVALID!"                           ç
    "IF!INITIATE!INVOKE!"                                          ç
    "IN!INPUT!IS!"                                                 ç
    "INDEX!INPUT-OUTPUT!"                                          ç
    "INDEXED!INSERT!"                                              ç
    /*   J   */                                                    ç
    "JUST!JUSTIFIED!"                                              ç
    /*   K   */                                                    ç
    "KANJI!KEY!"                                                   ç
    /*   L   */                                                    ç
    "LABEL!LIMIT!LINES!"                                           ç
    "LAST!LIMITS!LINKAGE!"                                         ç
    "LEADING!LINAGE!LOCAL-STORAGE!"                                ç
    "LEFT!LINAGE-COUNTER!LOCK!"                                    ç
    "LINE!LENGTH!LOW-VALUE!"                                       ç
    "LESS!LINE-COUNTER!LOW-VALUES!"                                ç
    /*   M   */                                                    ç
    "MEMORY!METHOD!MORE-LABELS!"                                   ç
    "MERGE!METHOD-ID!MOVE!"                                        ç
    "MESSAGE!MODE!MULTIPLE!"                                       ç
    "METACLASS!MODULES!MULTIPLY!"                                  ç
    /*   N   */                                                    ç
    "NATIVE!NO!NUMBER!"                                            ç
    "NATIVE_BINARY!NOT!NUMERIC!"                                   ç
    "NEGATIVE!NULL!NUMERIC-EDITED!"                                ç
    "NEXT!NULLS!"                                                  ç
    /*   O   */                                                    ç
    "OBJECT!ON!OTHER!"                                             ç
    "OBJECT-COMPUTER!OPEN!OUTPUT!"                                 ç
    "OCCURS!OPTIONAL!OVERFLOW!"                                    ç
    "OF!OR!OVERRIDE!"                                              ç
    "OFF!ORDER!"                                                   ç
    "OMITTED!ORGANIZATION!"                                        ç
    /*   P   */                                                    ç
    "PACKED-DECIMAL!PIC!PROCEDURE-POINTER!"                        ç
    "PADDING!PICTURE!PROCEDURES!"                                  ç
    "PAGE!PLUS!PROCEED!"                                           ç
    "PAGE-COUNTER!POINTER!PROCESSING!"                             ç
    "PASSWORD!POSITION!PROGRAM!"                                   ç
    "PERFORM!POSITIVE!PROGRAM-ID!"                                 ç
    "PF!PRINTING!PURGE!"                                           ç
    "PH!PROCEDURE!"                                                ç
    /*   Q   */                                                    ç
    "QUEUE!QUOTE!QUOTES!"                                          ç
    /*   R   */                                                    ç
    "RANDOM!RELATIVE!RESERVE!"                                     ç
    "RD!RELEASE!RESET!"                                            ç
    "READ!RELOAD!RETURN!"                                          ç
    "READY!REMAINDER!RETURN-CODE!"                                 ç
    "RECEIVE!REMOVAL!RETURNING!"                                   ç
    "RECORD!RENAMES!REVERSED!"                                     ç
    "RECORDING!REPLACE!REWIND!"                                    ç
    "RECORDS!REPLACING!REWRITE!"                                   ç
    "RECURSIVE!REPORT!RF!"                                         ç
    "REDEFINES!REPORTING!RH!"                                      ç
    "REEL!REPORTS!RIGHT!"                                          ç
    "REFERENCE!REPOSITORY!ROUNDED!"                                ç
    "REFERENCES!RERUN!RUN!"                                        ç
    /*   S   */                                                    ç
    "SAME!SIGN!STANDARD!"                                          ç
    "SD!SIZE!STANDARD-1!"                                          ç
    "SEARCH!SKIP1!STANDARD-2!"                                     ç
    "SECTION!SKIP2!START!"                                         ç
    "SECURITY!SKIP3!STATUS!"                                       ç
    "SEGMENT!SORT!STOP!"                                           ç
    "SEGMENT-LIMIT!SORT-CONTROL!STRING!"                           ç
    "SELECT!SORT-CORE-SIZE!SUB-QUEUE-1!"                           ç
    "SELF!SORT-FILE-SIZE!SUB-QUEUE-2!"                             ç
    "SEND!SORT-MERGE!SUB-QUEUE-3!"                                 ç
    "SENTENCE!SORT-MESSAGE!SUBTRACT!"                              ç
    "SEPARATE!SORT-MODE-SIZE!SUM!"                                 ç
    "SEQUENCE!SUPER!SORT-RETURN!"                                  ç
    "SEQUENTIAL!SOURCE!SUPPRESS!"                                  ç
    "SERVICE!SOURCE-COMPUTER!SYMBOLIC!"                            ç
    "SET!SYNC!SPACE!"                                              ç
    "SHIFT-IN!SYNCHRONIZED!SPACES!"                                ç
    "SHIFT-OUT!SPECIAL-NAMES!"                                     ç
    /*   T   */                                                    ç
    "TABLE!TEXT!TITLE!"                                            ç
    "THAN!TO!TALLY!"                                               ç
    "TALLYING!THEN!TOP!"                                           ç
    "TAPE!THROUGH!TRACE!"                                          ç
    "TERMINAL!THRU!TRAILING!"                                      ç
    "TERMINATE!TIME!TRUE!"                                         ç
    "TEST!TIMES!TYPE!"                                             ç
    /*   U   */                                                    ç
    "UNIT!UP!USE!"                                                 ç
    "UNSTRING!UPON!USING!"                                         ç
    "UNTIL!USAGE!"                                                 ç
    /*   V   */                                                    ç
    "VALUE!VALUES!VARYING!"                                        ç
    /*   W   */                                                    ç
    "WHEN!WORDS!WRITE-ONLY!"                                       ç
    "WORKING-STORAGE!WHEN-COMPILED!"                               ç
    "WITH!WRITE"                                                   ç
    /*   X   */                                                    ç
    /*   Y   */                                                    ç
    /*   Z   */                                                    ç
    "ZERO!ZEROES!ZEROS!"                                           ç
    /*  END  */                                                    ç
    ")(çç.! !,!$!'!ç")(.*)";

  /*    _____________________________________________________
      _(                                                     )_
     =_                   S Y M B O L S                       _=
       (_____________________________________________________)
                                                                  */

    char       *ptrnSymbols = "^( !,)*("                          ç
                            "çç.!"             /*  .        */    ç
                            "çç+!çç-!"         /*  +  -     */    ç
                            "çç(!çç)!"         /*  (  )     */    ç
                            "çç*çç*!çç*!çç/!"  /*  ** *  /  */    ç
                            "<=!>=!"           /*  <= >=    */    ç
                            "<!>!=!"           /*  <  >  =  */    ç
                            ":!çç$"            /*  :  $     */    ç
                            ")(.*)";

  /*    _____________________________________________________
      _(                                                     )_
     =_                   E N D  L I N E                     _=
       (_____________________________________________________)
                                                                  */

    char       *ptrnEndLine = "^(( !,)*)$";

  /*    _____________________________________________________
      _(                                                     )_
     =_                     S P A C E                        _=
       (_____________________________________________________)
                                                                  */

    char       *ptrnSpace = "(^( !,)+)";


  /*    ______________________________
      _(                              )_
     =_    SPECIAL REGISTER KEYWORD    _=
       (______________________________)
                                                                  */

    char       *ptrnSpclReg  = "^( !,)*"                           ç
                               "(ADDRESS!"                         ç
                               "DEBUG-ITEM!DEBUG-LINE!DEBUG-NAME!" ç
                               "LENGTH!RETURN-CODE!SORT-RETURN!"   ç
                               "WHEN-COMPILED!TALLY)"              ç
                               "(çç.! !,!$!'!ç")(.*)";

  /*    ______________________________
      _(                              )_
     =_  FIGURATIVE CONSTANTS KEYWORD  _=
       (______________________________)
                                                                  */

    char       *ptrnFgrtvConst = "^( !,)*("                        ç
                                 "ALL!"                            ç
                                 "ZERO!ZEROS!ZEROES!"              ç
                                 "SPACE!SPACES!"                   ç
                                 "HIGH-VALUE!HIGH-VALUES!"         ç
                                 "LOW-VALUE!LOW-VALUES!"           ç
                                 "QUOTE!QUOTES"                    ç
                                 ")(çç.! !,!$!'!ç")(.*)";

  /*    _____________________________
      _(                             )_
     =_        NUMERIC LITERAL        _=
       (_____________________________)
                                                                  */

    char       *ptrnNumeric = "^("                                  ç
                              "ZERO!ZEROS!ZEROES!"                  ç
                              "(Ýçç+çç-~?Ý0-9~+)!"       /* Intgr */ç
                              "(Ýçç+çç-~?Ý0-9~*,Ý0-9~+)" /* Decim */ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_        QUOTED LITERAL         _=
       (_____________________________)
                                                                  */

    char       *ptrnQuoted = "^("                                    ç
                             "('(Ý^'~!'')*')!"            /*  '.' */ ç
                             "(ç"(Ý^ç"~!ç"ç")*ç")!"       /*  "." */ ç
                             "(ÝXx~Ý'~Ý0-9A-Fa-f~+Ý'~)!"  /* x'.' */ ç
                             "(ÝXx~Ýç"~Ý0-9A-Fa-f~+Ýç"~)" /* x"." */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_    SINGLE QUOTED LITERAL      _=
       (_____________________________)
                                                                  */

    char       *ptrnSQuoted = "^("                                  ç
                             "('(Ý^'~!'')*')!"            /*  '.' */ ç
                             "(ÝXx~Ý'~Ý0-9A-Fa-f~+Ý'~)"  /* x'.' */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_    DOUBLE QUOTED LITERAL      _=
       (_____________________________)
                                                                  */

    char       *ptrnDQuoted = "^("                                   ç
                             "(ç"(Ý^ç"~!ç"ç")*ç")!"       /*  "." */ ç
                             "(ÝXx~Ýç"~Ý0-9A-Fa-f~+Ýç"~)" /* x"." */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_      HEXADECIMAL LITERAL      _=
       (_____________________________)
                                                                  */

    char       *ptrnHex     = "^("                                   ç
                             "(ÝXx~Ý'~Ý0-9A-Fa-f~+Ý'~)!"  /* x'.' */ ç
                             "(ÝXx~Ýç"~Ý0-9A-Fa-f~+Ýç"~)" /* x"." */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_      ALPHANUMERIC LITERAL     _=
       (_____________________________)
                                                                  */

    char       *ptrnAlphanum = "^("                                  ç
                             "('(Ý^'~!'')*')!"            /*  '.' */ ç
                             "(ç"(Ý^ç"~!ç"ç")*ç")"       /*  "." */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_        INTEGER LITERAL        _=
       (_____________________________)
                                                                  */

    char       *ptrnIntgr    = "^("                                 ç
                             "(Ýçç+çç-~?Ý0-9~+)"          /*  987 */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_        DECIMAL LITERAL        _=
       (_____________________________)
                                                                  */

    char       *ptrnDecim    = "^("                                ç
                             "(Ýçç+çç-~?Ý0-9~*,Ý0-9~+)"             ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_      UNSIGNED NUMERIC         _=
       (_____________________________)
                                                                  */

    char       *ptrnUnsigned = "^("                               ç
                             "(Ý0-9~+)!"                /* 987 */  ç
                             "(Ý0-9~*,Ý0-9~+)"          /* 9,7 */  ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_      POSITIVE NUMERIC         _=
       (_____________________________)
                                                                  */

    char       *ptrnPositive = "^("                               ç
                             "(çç+Ý0-9~+)!"             /* +987 */ ç
                             "(çç+Ý0-9~*,Ý0-9~+)"       /* +9,7 */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_      NEGATIVE NUMERIC         _=
       (_____________________________)
                                                                  */

    char       *ptrnNegative = "^("                                 ç
                             "(çç-Ý0-9~+)!"             /* -987 */ ç
                             "(çç-Ý0-9~*,Ý0-9~+)"       /* -9,7 */ ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_         LEVEL NUMBER          _=
       (_____________________________)
                                                                  */

    char       *ptrnLvlNum = "^("                                   ç
                             "(Ý0~?Ý1-9~!Ý1-4~Ý0-9~!66!77!88)"     ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_      RELATIONAL OPERATOR      _=
       (_____________________________)
                                                                  */

    char       *ptrnRelOp  = "^("                                   ç
                             "(<!>!<=!>=!=)"                       ç
                              ")$";

  /*    _____________________________
      _(                             )_
     =_      ARITHMITIC OPERATOR      _=
       (_____________________________)
                                                                  */

    char       *ptrnAritOp  = "^("                                  ç
                              "çç+!çç-!"         /*  +  -     */   ç
                              "çç(!çç)!"         /*  (  )     */   ç
                              "çç*çç*!çç*!çç/"  /*  ** *  /  */   ç
                              ")$";

  /*
    char       *ptrnLiter2 = "^( !,)*"                              ç
                            "(ç"(Ý^ç"~!ç"ç")*ç")"                   ç
                            "(Ý^ç"~!$)(.*)";
  */
  /*-----------------------------------*/
  /* Pattern pour HEXA Literal X'FF'   */
  /*-----------------------------------*/
  /*char       *ptrnHexL1  = "^( !,)*"                              ç
                            "(ÝXx~Ýç"~Ý0-9A-Fa-f~+Ýç"~)"            ç
                            "(Ý^ç"~!$)(.*)";

    char       *ptrnHexL2  = "^( !,)*"                              ç
                            "(ÝXx~Ý'~Ý0-9A-Fa-f~+Ý'~)"              ç
                            "(Ý^'~!$)(.*)";
  */
  /*-----------------------------*/
  /* Pattern pour Integer        */
  /*-----------------------------*/
  /*char       *ptrnIntgr = "^( !,)*"                             ç
                            "(Ýçç+çç-~?Ý0-9~+)"                   ç
                            "(.)(.*)";
  */
  /*-----------------------------*/
  /* Pattern pour Level Number   */
  /*-----------------------------*/
  /*char       *ptrnLvlnum = "(Ý0~?Ý1-9~!Ý1-4~Ý0-9~!77)";

  */
  /*-----------------------------*/
  /* Pattern pour Level 66       */
  /*-----------------------------*/
  /*char       *ptrnLvl66  = "66";
  */
  /*-----------------------------*/
  /* Pattern pour Level 88       */
  /*-----------------------------*/
  /*char       *ptrnLvl88  = "88";
  */
  /*-----------------------------*/
  /* Pattern pour Decimal        */
  /*-----------------------------*/
  /*char       *ptrnDecim  = "^( !,)*"                             ç
                            "(Ýçç+çç-~?Ý0-9~*,Ý0-9~+)"             ç
                            "(.)(.*)";
  */
  /*-------------------------------*/
  /* Pattern pour Unsigned integer */
  /*-------------------------------*/
  /*char       *ptrnUintgr  = "^(Ý0-9~+)$";
  */

  /*---------------------------------------------------------------*/
  /*---------------------------------------------------------------*/
  /*---------------------------------------------------------------*/

    int         rc=0;
    int         i=0;
    int         j=0;
    size_t      nmatch = NB_MATCH_MAX;
    regmatch_t  pmatchÝNB_MATCH_MAX~;
    char        bufferÝ100~;
    char        strÝ480~;

    static int  rets_len =0;
    static char rets_dataÝ480~="";

    char        argsÝ480~="";

    strcpy(args,ln_8_72);

  /*---------------------------------------------------------------*/
  /*---------------------------------------------------------------*/
  /*---------------------------------------------------------------*/

  /*---------------------------------------------------------------*/
  /* Ordre des REGEX                                               */
  /*---------------------------------------------------------------*/
  /* 1  - Keyword                                                  */
  /* 10 - Special registers                                        */
  /* 101- Figurative constants                                     */
  /* 11 - Hexa Literal1 & Hexa Literal2                            */
  /* 2  - Identifier                                               */
  /* 3  - Literal1 & Literal2                                      */
  /* 31 - Decimal                                                  */
  /* 32 - Integer                                                  */
  /* 4  - Period                                                   */
  /*      & plus minus equal expon divid multp Lbrack Rbrack colon */
  /* 5  - EndLine                                                  */
  /* 6  - Error                                                    */
  /*---------------------------------------------------------------*/
    /* Pointer Array for pregs order for type*/
    regex_npp   pregs ÝNB_REGEX_MAX~;

    int nb_regex_for_type;

    /* Default pregs order (empty context) */

    pregsÝj~.name ="KEYWORD";
    pregsÝj~.ptrn =ptrnKeywoAll;
    pregsÝj~.preg =&pregKeywoAll;
    j++;
    pregsÝj~.name ="LITERAL";
    pregsÝj~.ptrn =ptrnLiterQuot;
    pregsÝj~.preg =&pregLiterQuot;
    j++;
    pregsÝj~.name ="LITERAL";
    pregsÝj~.ptrn =ptrnLiterNum;
    pregsÝj~.preg =&pregLiterNum;
    j++;
    pregsÝj~.name ="IDENTIFIER";
    pregsÝj~.ptrn =ptrnIdent;
    pregsÝj~.preg =&pregIdent;
    j++;
    pregsÝj~.name ="SYMBOL";
    pregsÝj~.ptrn =ptrnSymbols;
    pregsÝj~.preg =&pregSymbols;
    j++;
    pregsÝj~.name ="ENDLINE";
    pregsÝj~.ptrn =ptrnEndLine;
    pregsÝj~.preg =&pregEndLine;
    j++;

    /* Space ??
    pregsÝj~.name ="SPACE";
    pregsÝj~.ptrn =ptrnSpace;
    pregsÝj~.preg =&pregSpace;
    j++; */

 /* pregsÝj~.name ="KEYWORD";
    pregsÝj~.ptrn =ptrnKeywoAll;
    pregsÝj~.preg =&pregKeywoAll;
    j++;
    pregsÝj~.name ="SPECIAL REGISTER";
    pregsÝj~.ptrn =ptrnSpclReg;
    pregsÝj~.preg =&pregSpclReg;
    j++;
    pregsÝj~.name ="FIGURATIVE CONST";
    pregsÝj~.ptrn =ptrnFgrtvConst;
    pregsÝj~.preg =&pregFgrtvConst;
    j++;
    pregsÝj~.name ="HEXLITERAL";
    pregsÝj~.ptrn =ptrnHexL1;
    pregsÝj~.preg =&pregHexL1;
    j++;
    pregsÝj~.name ="HEXLITERAL";
    pregsÝj~.ptrn =ptrnHexL2;
    pregsÝj~.preg =&pregHexL2;
    j++;
    pregsÝj~.name ="IDENTIFIER";
    pregsÝj~.ptrn =ptrnIdent;
    pregsÝj~.preg =&pregIdent;
    j++;
    pregsÝj~.name ="LITERAL";
    pregsÝj~.ptrn =ptrnLiter1;
    pregsÝj~.preg =&pregLiter1;
    j++;
    pregsÝj~.name ="LITERAL";
    pregsÝj~.ptrn =ptrnLiter2;
    pregsÝj~.preg =&pregLiter2;
    j++;
    pregsÝj~.name ="DECIMAL";
    pregsÝj~.ptrn =ptrnDecim;
    pregsÝj~.preg =&pregDecim;
    j++;
    pregsÝj~.name ="INTEGER";
    pregsÝj~.ptrn =ptrnIntgr;
    pregsÝj~.preg =&pregIntgr;
    j++;
    pregsÝj~.name ="SYMBOL";
    pregsÝj~.ptrn =ptrnSymbols;
    pregsÝj~.preg =&pregSymbols;
    j++;
    pregsÝj~.name="ENDLINE";
    pregsÝj~.ptrn=ptrnEndLine;
    pregsÝj~.preg=&pregEndLine;
    j++;
  */
    nb_regex_for_type = j;

  /*---------------------------------------------------------------*/
  /*-------------- ! Context Sensitive Lexer ! --------------------*/
  /*---------------------------------------------------------------*/
  /* If clause data_pic_chars => add PICCHARS as the first regex   */
  /*---------------------------------------------------------------*/
  /*                          => next is the pattern for space     */
  /*---------------------------------------------------------------*/

    if((strcmp(_context.clause,"data_pic_chars"))==0)é


       j = 0;

       pregsÝj~.name ="PICCHARS";
       pregsÝj~.ptrn =ptrnPicChars;
       pregsÝj~.preg =&pregPicChars;
       j++;
       pregsÝj~.name ="SYMBOL";
       pregsÝj~.ptrn =ptrnSymbols;
       pregsÝj~.preg =&pregSymbols;
       j++;
       pregsÝj~.name ="SPACE";
       pregsÝj~.ptrn =ptrnSpace;
       pregsÝj~.preg =&pregSpace;
       j++;
       pregsÝj~.name ="KEYWORD";
       pregsÝj~.ptrn =ptrnKeywoAll;
       pregsÝj~.preg =&pregKeywoAll;
       j++;
       pregsÝj~.name ="LITERAL";
       pregsÝj~.ptrn =ptrnLiterQuot;
       pregsÝj~.preg =&pregLiterQuot;
       j++;
       pregsÝj~.name ="LITERAL";
       pregsÝj~.ptrn =ptrnLiterNum;
       pregsÝj~.preg =&pregLiterNum;
       j++;
       pregsÝj~.name ="IDENTIFIER";
       pregsÝj~.ptrn =ptrnIdent;
       pregsÝj~.preg =&pregIdent;
       j++;
       pregsÝj~.name ="ENDLINE";
       pregsÝj~.ptrn =ptrnEndLine;
       pregsÝj~.preg =&pregEndLine;
       j++;
/*
       pregsÝj~.name ="PICCHARS";
       pregsÝj~.ptrn =ptrnPicChars;
       pregsÝj~.preg =&pregPicChars;
       j++;
*/   /*pregsÝj~.name ="SYMBOL";
       pregsÝj~.ptrn =ptrnPerio;
       pregsÝj~.preg =&pregPerio;
       j++;*/
/*     pregsÝj~.name ="SYMBOL";
       pregsÝj~.ptrn =ptrnSymbols;
       pregsÝj~.preg =&pregSymbols;
       j++;
       pregsÝj~.name="SPACE";
       pregsÝj~.ptrn=ptrnSpace;
       pregsÝj~.preg=&pregSpace;
       j++;
       pregsÝj~.name ="KEYWORD";
       pregsÝj~.ptrn =ptrnKeywoAll;
       pregsÝj~.preg =&pregKeywoAll;
       j++;
       pregsÝj~.name ="SPECIAL REGISTER";
       pregsÝj~.ptrn =ptrnSpclReg;
       pregsÝj~.preg =&pregSpclReg;
       j++;
       pregsÝj~.name ="FIGURATIVE CONST";
       pregsÝj~.ptrn =ptrnFgrtvConst;
       pregsÝj~.preg =&pregFgrtvConst;
       j++;
       pregsÝj~.name ="HEXLITERAL";
       pregsÝj~.ptrn =ptrnHexL1;
       pregsÝj~.preg =&pregHexL1;
       j++;
       pregsÝj~.name ="HEXLITERAL";
       pregsÝj~.ptrn =ptrnHexL2;
       pregsÝj~.preg =&pregHexL2;
       j++;
       pregsÝj~.name ="IDENTIFIER";
       pregsÝj~.ptrn =ptrnIdent;
       pregsÝj~.preg =&pregIdent;
       j++;
       pregsÝj~.name ="LITERAL";
       pregsÝj~.ptrn =ptrnLiter1;
       pregsÝj~.preg =&pregLiter1;
       j++;
       pregsÝj~.name ="LITERAL";
       pregsÝj~.ptrn =ptrnLiter2;
       pregsÝj~.preg =&pregLiter2;
       j++;
       pregsÝj~.name ="DECIMAL";
       pregsÝj~.ptrn =ptrnDecim;
       pregsÝj~.preg =&pregDecim;
       j++;
       pregsÝj~.name ="INTEGER";
       pregsÝj~.ptrn =ptrnIntgr;
       pregsÝj~.preg =&pregIntgr;
       j++;
       pregsÝj~.name="ENDLINE";
       pregsÝj~.ptrn=ptrnEndLine;
       pregsÝj~.preg=&pregEndLine;
       j++;
 */    nb_regex_for_type = j;
    è

  /* Additional Regex for token attributes   */
  regex_npp   pregs_attr ÝNB_REGEX_MAX~;

  int nb_regex_for_attr;
  j =0;

  pregs_attrÝj~.name ="SPECIAL REGISTER";
  pregs_attrÝj~.ptrn =ptrnSpclReg;
  pregs_attrÝj~.preg =&pregSpclReg;
  j++;
  pregs_attrÝj~.name ="FIGURATIVE CONST";
  pregs_attrÝj~.ptrn =ptrnFgrtvConst;
  pregs_attrÝj~.preg =&pregFgrtvConst;
  j++;
  pregs_attrÝj~.name ="NUMERIC";
  pregs_attrÝj~.ptrn =ptrnNumeric;
  pregs_attrÝj~.preg =&pregNumeric;
  j++;
  pregs_attrÝj~.name ="QUOTED";
  pregs_attrÝj~.ptrn =ptrnQuoted;
  pregs_attrÝj~.preg =&pregQuoted;
  j++;
  pregs_attrÝj~.name ="SINGLE QUOTE";
  pregs_attrÝj~.ptrn =ptrnSQuoted;
  pregs_attrÝj~.preg =&pregSQuoted;
  j++;
  pregs_attrÝj~.name ="DOUBLE QUOTED";
  pregs_attrÝj~.ptrn =ptrnDQuoted;
  pregs_attrÝj~.preg =&pregDQuoted;
  j++;
  pregs_attrÝj~.name ="HEX";
  pregs_attrÝj~.ptrn =ptrnHex;
  pregs_attrÝj~.preg =&pregHex;
  j++;
  pregs_attrÝj~.name ="ALPHANUMERIC";
  pregs_attrÝj~.ptrn =ptrnAlphanum;
  pregs_attrÝj~.preg =&pregAlphanum;
  j++;
  pregs_attrÝj~.name ="INTEGER";
  pregs_attrÝj~.ptrn =ptrnIntgr;
  pregs_attrÝj~.preg =&pregIntgr;
  j++;
  pregs_attrÝj~.name ="DECIMAL";
  pregs_attrÝj~.ptrn =ptrnDecim;
  pregs_attrÝj~.preg =&pregDecim;
  j++;
  pregs_attrÝj~.name ="UNSIGNED";
  pregs_attrÝj~.ptrn =ptrnUnsigned;
  pregs_attrÝj~.preg =&pregUnsigned;
  j++;
  pregs_attrÝj~.name ="POSITIVE";
  pregs_attrÝj~.ptrn =ptrnPositive;
  pregs_attrÝj~.preg =&pregPositive;
  j++;
  pregs_attrÝj~.name ="NEGATIVE";
  pregs_attrÝj~.ptrn =ptrnNegative;
  pregs_attrÝj~.preg =&pregNegative;
  j++;
  pregs_attrÝj~.name ="LEVEL NUMBER";
  pregs_attrÝj~.ptrn =ptrnLvlNum;
  pregs_attrÝj~.preg =&pregLvlnum;
  j++;
  pregs_attrÝj~.name ="RELATIONAL OP";
  pregs_attrÝj~.ptrn =ptrnRelOp;
  pregs_attrÝj~.preg =&pregRelOp;
  j++;
  pregs_attrÝj~.name ="ARITHMITIC OP";
  pregs_attrÝj~.ptrn =ptrnAritOp;
  pregs_attrÝj~.preg =&pregAritOp;
  j++;

  nb_regex_for_attr = j;

  /*
  regex_npp   reg_lvlnum;
  regex_npp   reg_lvl66;
  regex_npp   reg_lvl88;
  regex_npp   reg_uintgr;

  reg_lvlnum.name="LVLNUM";
  reg_lvlnum.ptrn=ptrnLvlnum;
  reg_lvlnum.preg=&pregLvlnum;

  reg_lvl66.name="LVL66";
  reg_lvl66.ptrn=ptrnLvl66;
  reg_lvl66.preg=&pregLvl66;

  reg_lvl88.name="LVL88";
  reg_lvl88.ptrn=ptrnLvl88;
  reg_lvl88.preg=&pregLvl88;

  reg_uintgr.name="UINTEGER";
  reg_uintgr.ptrn=ptrnUintgr;
  reg_uintgr.preg=&pregUintgr;

  if(§(compil_regexp(reg_lvlnum))) return _ret;
  if(§(compil_regexp(reg_lvl66))) return _ret;
  if(§(compil_regexp(reg_lvl88))) return _ret;
  if(§(compil_regexp(reg_uintgr))) return _ret;
  */

  /*---------------------------------------------------------------*/
  /*-------------- ! Compilation des Regex  ! ---------------------*/
  /*---------------------------------------------------------------*/


     /* _______________________________
      _(                               )_
     =_  COMPILE REGEX FOR TOKEN TYPE   _=
       (_______________________________)*/

    i=0;
    while ((i < nb_regex_for_type) && (compil_regexp(pregsÝi~)))

    é
    /* printf("Compilation regex (%s) reussie çn",pregsÝi~.name); */
       i++;
    è


    /* Sortie prémature : erreur compilation */
    if (i < nb_regex_for_type) exit(EXIT_FAILURE);


     /* ____________________________________
      _(                                    )_
     =_  COMPILE REGEX FOR TOKEN ATTRIBUTES  _=
       (____________________________________)*/


    i=0;
    while ((i < nb_regex_for_attr) && (compil_regexp(pregs_attrÝi~)))

    é
    /* printf("Compilation regex (%s) reussie çn",
              pregs_attrÝi~.name); */
       i++;
    è


    /* Sortie prémature : erreur compilation */
    if (i < nb_regex_for_attr) exit(EXIT_FAILURE);


     /* _____________________________
      _(                             )_
     =_  MATCH REGEX FOR TOKEN TYPE   _=
       (_____________________________)*/

    i =0;
    while ((i < nb_regex_for_type) &&
          ((rc =regexec(pregsÝi~.preg, args, nmatch, pmatch, 0)) §= 0))

    é
     /*affich_fail_match(rc,args,pregsÝi~.name,pregsÝi~.preg);*/
       i++;
    è

    /* match found */
    if (i < nb_regex_for_type) é

        /* Display matched sub-expression */
      /*affich_subexpr(pmatch,args);*/

        /* extraire token vers var tmp : str */
        sprintf(str,"%.*s",pmatchÝ2~.rm_eo - pmatchÝ2~.rm_so,
                  args+pmatchÝ2~.rm_so);

        /* reduire args */
        /*
        sprintf(args,"%.*s",pmatchÝ3~.rm_eo - pmatchÝ3~.rm_so,
                  args+pmatchÝ3~.rm_so); */

        reduction_len  = 65 - strlen(args);

        sprintf(args,"%.*s",((strlen(args))-(pmatchÝ2~.rm_eo))
                 ,args+(pmatchÝ2~.rm_eo));

        _ret.tkn_colnum = pmatchÝ2~.rm_so + 1 + reduction_len;
        _ret.tkn_len    = pmatchÝ2~.rm_eo - pmatchÝ2~.rm_so;

      /*printf("tokenizer     :strlen(args) (%d) reduction_len (%d)" ç
        " tkn_colnum (%d) pmatchÝ2~.rm_so (%d) tkn_len (%d) çn",
        strlen(args),reduction_len,_ret.tkn_colnum,pmatchÝ2~.rm_so,
        _ret.tkn_len);
      */
        /* concat str avec rets */
        strcat(rets_data,pregsÝi~.name);
        strcat(rets_data,";;");
        strcat(rets_data,str);
        strcat(rets_data,";;");
        char* temp="ç0";
        sprintf(temp, "%d", _ret.tkn_colnum);
        strcat(rets_data,temp);
        strcat(rets_data,";;");

        _ret.tkn_type   = pregsÝi~.name;
        _ret.tkn_val    = str;

        /*
        if ((rc =regexec(reg_lvlnum.preg,str,nmatch,pmatch,0)) == 0)é
            _ret.tkn_attrÝ0~ = "LVLNUM";
            printf ("LVLNUM found çn");
        è
        if ((rc =regexec(reg_lvl66.preg,str,nmatch,pmatch,0)) == 0)é
            _ret.tkn_attrÝ0~= "LVL66";
            printf ("LVL66  found çn");
        è
        if ((rc =regexec(reg_lvl88.preg,str,nmatch,pmatch,0)) == 0)é
            _ret.tkn_attrÝ0~= "LVL88";
            printf ("LVL88  found çn");
        è
        if ((rc =regexec(reg_uintgr.preg,str,nmatch,pmatch,0)) == 0)é
            _ret.tkn_attrÝ1~= "UINTEGER";
            printf ("UINTEGER  found çn");
        è */
    è

    /* no match found */
    else é

       strcpy(rets_data,"ERROR;;");
       _ret.tkn_type = "ERROR";
       _ret.tkn_val = "ERROR";

       printf("ERROR, args :%s",args);
    è

     /* ____________________________________
      _(                                    )_
     =_  COMPILE REGEX FOR TOKEN ATTRIBUTES  _=
       (____________________________________)*/

    i =0;
    j =0;
    _ret.tkn_attr_len =0;
    while ((i < nb_regex_for_attr) &&
           (rc=strcmp(_ret.tkn_val,"ERROR"))§=0)
    é
       if((rc =regexec(pregs_attrÝi~.preg,str,nmatch,pmatch,0)) == 0)
       é
          /* Display matched sub-expression */
        /*affich_subexpr(pmatch,str); */
          _ret.tkn_attrÝj~=pregs_attrÝi~.name;
          j++;
       è
       else
       é
        /*affich_fail_match(rc,args,pregsÝi~.name,pregsÝi~.preg);*/
       è

       i++;
    è
    _ret.tkn_attr_len=j;

    rets_len = strlen(rets_data);
    /*
    printf("çn");
    printf("*----------------------------------------------*çn");
    printf("*--------------  END LEXERCOB  ----------------*çn");
    printf("*----------------------------------------------*çn");
    printf("*   Rets length : %d çn", rets_len);
    printf("*   Rets data   :'%s'çn", rets_data);
    printf("*----------------------------------------------*çn");
    */
    printf("çn");
    printf("*----------------------------------------------*çn");
    printf("*--------------   TOKENIZER    ----------------*çn");
    printf("*----------------------------------------------*çn");
    printf("*   Token Value : %s çn", _ret.tkn_val);
    printf("*   Token Type  : %s çn", _ret.tkn_type);
    printf("*   Token Line  : %d çn", _ret.tkn_lnnum);
    printf("*   Token Coln  : %d çn", _ret.tkn_colnum);
    printf("*   Token Length: %d çn", _ret.tkn_len);
    printf("*   Token attrs : %d çn", _ret.tkn_attr_len);
    printf("*----------------------------------------------*çn");

    i =0;
    while (i < _ret.tkn_attr_len) é
       printf("*   Token Attr  : %s çn", _ret.tkn_attrÝi~);
       i++;
    è
    printf("*----------------------------------------------*çn");

    /*
    regfree(&pregIdent);
    regfree(&pregPerio);
    regfree(&pregLiter1);
    regfree(&pregLiter2);
    regfree(&pregHexL1);
    regfree(&pregHexL2);
    regfree(&pregKeywoAll);
    regfree(&pregLBrack);
    regfree(&pregRBrack);
    regfree(&pregPlus);
    regfree(&pregMinus);
    regfree(&pregMultp);
    regfree(&pregDivid);
    regfree(&pregExpon);
    regfree(&pregEqual);
    regfree(&pregColon);
    regfree(&pregIntgr);
    regfree(&pregDecim);

    printf("tokenizer()   : ");
    printf("Token Value <%s> Token Type   <%s> çn",
            _ret.tkn_val,_ret.tkn_type);
    */
    /*
    printf("tokenizer()   : ");
    printf("args        : <%s>çn",args);
    printf("len args    : <%d>çn",strlen(args));
    */
    strcpy(ln_8_72,args);

    /*
    printf("tokenizer()   : ");
    printf("ln_8_72     : <%s>çn",ln_8_72);
    printf("len ln_8_72 : <%d>çn",strlen(ln_8_72));
    */
    return _ret;

è


int affich_subexpr(regmatch_t pmatchÝ~,char argsÝ~)é

   int i =0;

   printf("Whole expression :<");
   printf("%s",args);
   printf(">çn");

   for (i=1;i<NB_MATCH_MAX;i++)é

      printf("çnSub-expression %d, a matched sub-string " ç
             "ç"%.*sç" found at position %d to %d.çn ",
      i, pmatchÝi~.rm_eo - pmatchÝi~.rm_so,
      args+pmatchÝi~.rm_so,pmatchÝi~.rm_so,
      pmatchÝi~.rm_eo - 1);

   è
   printf("çn");

   return 1;
è

int affich_fail_match(int rc,char argsÝ~,char* ptrn,regex_t* preg)é

   char bufferÝ100~;

   regerror(rc, preg, buffer, 100);

   printf("failed to matchçn'%s'withçn'%s',çnRC :%d, '%s'çn"
             ,args, ptrn, rc, buffer);

   return 1;
è

int compil_regexp(regex_npp _regex_npp)é

    int  rc =0;
    char bufferÝ100~;

    /* Compiler la REGEXP pour ptrn dans preg */

    if ((rc = regcomp(_regex_npp.preg, _regex_npp.ptrn,
         REG_ICASE!REG_EXTENDED)) §= 0)
    é
       regerror(rc, _regex_npp.preg, buffer, 100);
       printf("regcomp(%s) fail RC (%d : '%s')çn",_regex_npp.name,
              rc, buffer);
       return 0;
    è
    /* printf("regcomp for (%s) succesful çn",_regex_npp.name);*/

    return 1;
è
£include <stdio.h>
£include <stdlib.h>
£include <stddef.h>

£include "asth"



/*---   SENTENCE   ---*/
ast*
make_sentence    (int nb_statement, struct ast* list_statement)é

  printf("sizeof(ast*) sentence (%zd)çn",sizeof(ast*));
  printf("sizeof(ast ) sentence (%zd)çn",sizeof(ast));

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.sentence.ast_name          = "SENTENCE";
  e->tag = SENTENCE;

  e->node.sentence.nb_statement = nb_statement;
  e->node.sentence.list_statement = NULL;

  /* if(nb_statement > 0 ) */
  e->node.sentence.list_statement = list_statement;

  e->next =NULL;

  printf("çn");
  printf("**********   SENTENCE   **********çn");
  printf("* SENTENCE AST BUILT SUCCESFULLY *çn");
  printf("**********************************çn");

  return e;

è

affich_sentence(ast* tree,scr_line* screen)é

   printf("printing sentence ... çn");

   ast* temp = NULL;

   printf("Drawing ast name  ... çn");
   draw_box(screen,tree->node.sentence.ast_name,"",1);
   printf("Drawing ast name  OK  çn");

   printf("Init iterator ...     çn");

   temp=tree->node.sentence.list_statement;

   printf("Iterating ...         çn");
   while(temp §= NULL)é
      printf("temp (%d) çn",temp);
      printf("Printinf inner stmnt ...  çn");
      affich_statement(temp,screen);
      printf("Printinf inner stmnt OK   çn");
      temp = temp->next;
      printf("temp (%d) çn",temp);
   è
   printf("Iterating OK      çn");

è

affich_statement(ast* tree,scr_line* screen)é

   printf("Switch for statement ... çn");
   ast* temp = NULL;

   printf("Statement (%s) çn",tagValuesÝtree->tag~);
   assert(tree->tag == DISPLAY_STM);

   if      (tagValuesÝtree->tag~ == "MOVE_STM")

           affich_move_stm(tree,screen);

   else if (tagValuesÝtree->tag~ == "DISPLAY_STM")

           affich_display_stm(tree,screen);

   else if (tagValuesÝtree->tag~ == "INITIALIZE_STM")

           affich_initialize_stm(tree,screen);

   else é

           printf("Unknown Tag for statement (%s) çn",
                                tagValuesÝtree->tag~);
           exit(EXIT_FAILURE);
   è
è

/*---   MOVE   ---*/
ast*
make_move        (int bool_corresp, struct ast* operand_g,
                  int nb_operand_r, struct ast* list_operand_r)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.move_stm.ast_name          = "MOVE";
  e->tag = MOVE_STM;



  e->next =NULL;
  return e;

è

affich_move_stm(ast* tree,scr_line* screen)é


è
/*---   DISPLAY   ---*/
ast*
make_display (int bool_upon, int bool_no_adv, char* upon_operand,
                   int nb_operand, struct ast* list_operand)é

  printf("sizeof(ast*) display (%zd)çn",sizeof(ast*));
  printf("sizeof(ast ) display (%zd)çn",sizeof(ast));
  ast* e = (ast*) malloc(sizeof(ast));
  e->node.display_stm.ast_name          = "DISPLAY";
  e->tag = DISPLAY_STM;

  e->node.display_stm.bool_upon         = bool_upon;
  e->node.display_stm.bool_no_adv       = bool_no_adv;
  /*strcpy(e->node.display_stm.upon_operand,upon_operand);*/
  e->node.display_stm.upon_operand = upon_operand;
  e->node.display_stm.nb_operand        = nb_operand;
  e->node.display_stm.list_operand   = NULL;

  if(nb_operand > 0 )
     e->node.display_stm.list_operand   = list_operand;

  e->next =NULL;

  printf("çn");
  printf("**********   DISPLAY    **********çn");
  printf("* DISPLAY  AST BUILT SUCCESFULLY *çn");
  printf("**********************************çn");

  return e;

è

affich_display_stm(ast* tree,scr_line* screen)é

   ast* temp = NULL;

   draw_box(screen,tree->node.display_stm.ast_name,"",1);

   temp=tree->node.display_stm.list_operand;

   while(temp §= NULL)é
      affich_operand(temp,screen);
      temp=temp->next;
   è

è

ast*
make_initialize  (int bool_repl, int nb_operand,
                  struct ast* list_operand)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.initialize_stm.ast_name          = "INITIALIZE";
  e->tag = INITIALIZE_STM;



  e->next =NULL;
  return e;


è

affich_initialize_stm(ast* tree,scr_line* screen)é


è
/*---   OPERAND   ---*/
ast*
make_operand (int bool_literal, int bool_identifier,
                  struct ast* operand)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.operand.ast_name          = "OPERAND";
  e->tag = OPERAND;


  e->next =NULL;
  printf("çn");
  printf("**********   OPERAND    **********çn");
  printf("* OPERAND  AST BUILT SUCCESFULLY *çn");
  printf("**********************************çn");

  return e;

è

affich_operand(ast* tree,scr_line* screen)é

   ast* temp = NULL;

   if      (tagValuesÝtree->tag~ == "LITERAL")

           affich_literal(tree,screen);

   else if (tagValuesÝtree->tag~ == "IDENTIFIER")

           affich_identifier(tree,screen);

   else exit(EXIT_FAILURE);

è

/*---   LITERAL   ---*/
ast*
make_literal     (char* value,
                  int bool_all, int bool_numeric,
                  int bool_alphanumeric,
                  int bool_hexadecimal, int bool_positive,
                  int bool_negative, int bool_unsigned,
                  int bool_singl_q, int bool_doubl_q,
                  int bool_intgr,   int bool_decim,
                  int bool_figurative,
                  int char_length)é

  printf("sizeof(ast*) literal (%zd)çn",sizeof(ast*));
  printf("sizeof(ast ) literal (%zd)çn",sizeof(ast));
  ast* e = (ast*) malloc(sizeof(ast));
  e->node.literal.ast_name          = "LITERAL";
  e->tag = LITERAL;

  e->node.literal.bool_all          = bool_all;
  e->node.literal.bool_numeric      = bool_numeric;
  e->node.literal.bool_alphanumeric = bool_alphanumeric;
  e->node.literal.bool_hexadecimal  = bool_hexadecimal;
  e->node.literal.bool_positive     = bool_positive;
  e->node.literal.bool_negative     = bool_negative;
  e->node.literal.bool_unsigned     = bool_unsigned;
  e->node.literal.bool_singl_q      = bool_singl_q;
  e->node.literal.bool_doubl_q      = bool_doubl_q;
  e->node.literal.bool_intgr        = bool_intgr;
  e->node.literal.bool_decim        = bool_decim;
  e->node.literal.bool_figurative   = bool_figurative;
  e->node.literal.char_length       = char_length;

  /*strcpy(e->node.literal.value,value);*/
  e->node.literal.value=value;

  e->next =NULL;

  printf("çn");
  printf("**********   LITERAL    **********çn");
  printf("* LITERAL  AST BUILT SUCCESFULLY *çn");
  printf("**********************************çn");

  return e;

è

affich_literal(ast* tree,scr_line* screen)é

   draw_box(screen,tree->node.literal.ast_name,
                   tree->node.literal.value,1);

è

ast*
make_identifier  (int bool_length, int bool_address,
                  char* special_reg_value,
                  struct ast* name, struct ast* qualif,
                  struct ast* subscript, struct ast* refmod)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.identifier.ast_name          = "IDENTIFIER";
  e->tag = IDENTIFIER;

  e->node.identifier.bool_length       = bool_length;
  e->node.identifier.bool_address      = bool_address;
/*strcpy(e->node.identifier.special_reg_value,special_reg_value);*/
  e->node.identifier.special_reg_value=special_reg_value;
  e->node.identifier.name              = name;
  e->node.identifier.qualif            = qualif;
  e->node.identifier.subscript         = subscript;
  e->node.identifier.refmod            = refmod;

  e->next =NULL;
  printf("çn");
  printf("**********   IDENTIFIER   **********çn");
  printf("* IDENTIFIER AST BUILT SUCCESFULLY *çn");
  printf("************************************çn");

  return e;

è

affich_identifier(ast* tree,scr_line* screen)é

   ast* name = tree->node.identifier.name;
   draw_box(screen,tree->node.identifier.ast_name,
                   name->node.ident_name.value,1);

   if(tree->node.identifier.qualif §= NULL)
      affich_ident_qualif(tree->node.identifier.qualif,screen);

   if(tree->node.identifier.refmod §= NULL)
      affich_ident_refmod(tree->node.identifier.refmod,screen);

   if(tree->node.identifier.subscript §= NULL)
      affich_ident_subscript(tree->node.identifier.subscript,screen);

è


ast*
make_ident_name_qualif
                 (struct ast* name, struct ast* qualif)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.ident_name_qualif.ast_name          = "IDENT_NAME_QUALIF";
  e->tag = IDENT_NAME_QUALIF;

  e->node.ident_name_qualif.name       = name;
  e->node.ident_name_qualif.qualif     = qualif;


  e->next =NULL;
  printf("çn");
  printf("***********  ID NAME QUALIF  ***********çn");
  printf("* ID NAME QUALIF AST BUILT SUCCESFULLY *çn");
  printf("****************************************çn");

  return e;

è

affich_ident_name_qualif(ast* tree,scr_line* screen)é


è

ast*
make_ident_name  (int length, char* value)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.ident_name.ast_name          = "IDENT_NAME";
  e->tag = IDENT_NAME;

  e->node.ident_name.length            = length;
  e->node.ident_name.value             = value;

  e->next =NULL;
  printf("çn");
  printf("***********  ID NAME  ***********çn");
  printf("* ID NAME AST BUILT SUCCESFULLY *çn");
  printf("*********************************çn");
  return e;


è

affich_ident_name(ast* tree,scr_line* screen)é

   draw_box(screen,tree->node.ident_name.ast_name,
                   tree->node.ident_name.value,1);


è

ast*
make_ident_qualif(struct ast* list_qualif)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.ident_qualif.ast_name          = "IDENT_QUALIF";
  e->tag = IDENT_QUALIF;

  e->node.ident_qualif.list_qualif     = list_qualif;


  e->next =NULL;
  printf("çn");
  printf("***********  ID QUALIF  ***********çn");
  printf("* ID QUALIF AST BUILT SUCCESFULLY *çn");
  printf("***********************************çn");
  return e;

è

affich_ident_qualif(ast* tree,scr_line* screen)é

   ast* temp = NULL;

   temp=tree->node.ident_qualif.list_qualif;

   while(temp §= NULL)é
      affich_ident_name(temp,screen);
      temp=temp->next;
   è


è


ast*
make_ident_subscript
                 (struct ast* list_subscript)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.ident_subscript.ast_name          = "IDENT_SUBSCRIPT";
  e->tag = IDENT_SUBSCRIPT;

  printf("çn");
  printf("***********  ID SUBSCR  ***********çn");
  printf("* ID SUBSCR AST BUILT SUCCESFULLY *çn");
  printf("***********************************çn");


  e->next =NULL;
  return e;


è

affich_ident_subscript(ast* tree,scr_line* screen)é

   draw_box(screen,tree->node.ident_subscript.ast_name,
                   "subscript value",1);


è


ast*
make_ident_refmod(struct ast* charleft, struct ast* length)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.ident_refmod.ast_name          = "IDENT_REFMOD";
  e->tag = IDENT_REFMOD;


  printf("çn");
  printf("***********  ID REFMOD  ***********çn");
  printf("* ID REFMOD AST BUILT SUCCESFULLY *çn");
  printf("***********************************çn");


  e->next =NULL;
  return e;


è

affich_ident_refmod(ast* tree,scr_line* screen)é

   draw_box(screen,tree->node.ident_refmod.ast_name,
                   "refmod value",1);


è

ast*
make_arith_exp   (char* oper, struct ast* left, struct ast* right)é

  ast* e = (ast*) malloc(sizeof(ast));
  e->node.arith_exp.ast_name          = "ARITH_EXP";
  e->tag = ARITH_EXP;


  e->next =NULL;
  return e;



è

affich_arith_exp(ast* tree,scr_line* screen)é


è

affich_special_reg(ast* tree,scr_line* screen)é


è

affich_binary_op(ast* tree,scr_line* screen)é


è

affich_unary_op(ast* tree,scr_line* screen)é


è

affich_declaration(ast* tree,scr_line* screen)é


è

                     /***                 ***/
ast*
append_list (struct ast* list, struct ast* toadd)é

  printf("çn");
  printf("append_list(%s) start ...çn",tagValuesÝlist->tag~);
  ast* head;



  if(list == NULL)é

     printf("list==NULL ... return to_add çn");

     printf("toadd (%d)çn",toadd);
     printf("toadd->next (%d)çn",toadd->next);

     return toadd;
  è

  head = list;

  while(list §= NULL)é
     printf("parcours de la liste ...     çn");
     list = list->next;
  è

  list=toadd;
  list->next=NULL;

  printf("append succesful             çn");
  printf("çn");

  return head;

è

/*              Affichage des AST                       */

affich_node (ast* tree,scr_line* screen)é

   if      (tree->tag == SENTENCE)

           affich_sentence(tree,screen);

   else if (tree->tag == DECLARATION)

           affich_declaration(tree,screen);

   else if (tree->tag == STATEMENT)

           affich_statement(tree,screen);

   else if (tree->tag == MOVE_STM)

           affich_move_stm(tree,screen);

   else if (tree->tag == DISPLAY_STM)

           affich_display_stm(tree,screen);

   else if (tree->tag == INITIALIZE_STM)

           affich_initialize_stm(tree,screen);

   else if (tree->tag == OPERAND)

           affich_operand(tree,screen);

   else if (tree->tag == LITERAL)

           affich_literal(tree,screen);

   else if (tree->tag == IDENTIFIER)

           affich_identifier(tree,screen);

   else if (tree->tag == IDENT_NAME)

           affich_ident_name(tree,screen);

   else if (tree->tag == IDENT_NAME_QUALIF)

           affich_ident_name_qualif(tree,screen);

   else if (tree->tag == IDENT_QUALIF)

           affich_ident_qualif(tree,screen);

   else if (tree->tag == IDENT_SUBSCRIPT)

           affich_ident_subscript(tree,screen);

   else if (tree->tag == IDENT_REFMOD)

           affich_ident_refmod(tree,screen);

   else if (tree->tag == SPECIAL_REG)

           affich_special_reg(tree,screen);

   else if (tree->tag == ARITH_EXP)

           affich_arith_exp(tree,screen);

   else if (tree->tag == BINARY_OP)

           affich_binary_op(tree,screen);

   else if (tree->tag == UNARY_OP)

           affich_unary_op(tree,screen);

   else    exit(EXIT_FAILURE);

è

/*              Free AST               */

free_node (ast* tree)é

   printf("free_node (%s) (%d) çn", tagValuesÝtree->tag~,tree->tag);
   printf("Looking for next ...çn");

   while (tree->next §= NULL)é
      printf("Next found.çn");

      free_node(tree->next);

   è
   printf("Looking for next OK çn");

   if      (tree->tag == SENTENCE)

           free_sentence(tree);

   else if (tree->tag == DECLARATION)

           free_declaration(tree);

   else if (tree->tag == STATEMENT)

           free_statement(tree);

   else if (tree->tag == MOVE_STM)

           free_move_stm(tree);

   else if (tree->tag == DISPLAY_STM)

           free_display_stm(tree);

   else if (tree->tag == INITIALIZE_STM)

           free_initialize_stm(tree);

   else if (tree->tag == OPERAND)

           free_operand(tree);

   else if (tree->tag == LITERAL)

           free_literal(tree);

   else if (tree->tag == IDENTIFIER)

           free_identifier(tree);

   else if (tree->tag == IDENT_NAME)

           free_ident_name(tree);

   else if (tree->tag == IDENT_NAME_QUALIF)

           free_ident_name_qualif(tree);

   else if (tree->tag == IDENT_QUALIF)

           free_ident_qualif(tree);

   else if (tree->tag == IDENT_SUBSCRIPT)

           free_ident_subscript(tree);

   else if (tree->tag == IDENT_REFMOD)

           free_ident_refmod(tree);

   else if (tree->tag == SPECIAL_REG)

           free_special_reg(tree);

   else if (tree->tag == ARITH_EXP)

           free_arith_exp(tree);

   else if (tree->tag == BINARY_OP)

           free_binary_op(tree);

   else if (tree->tag == UNARY_OP)

           free_unary_op(tree);

   else é
           printf("Unknown Tag (%s) çn", tagValuesÝtree->tag~);
           exit(EXIT_FAILURE);
   è

è

free_sentence(ast* tree)é

   printf("Free_sentence ...çn");
   free_node(tree->node.sentence.list_statement);

   free(tree);
   printf("Free_sentence OK çn");

è

free_declaration(ast* tree)é

   printf("Free_declaration ...çn");
   free(tree);
   printf("Free_declaration OKçn");

è

free_statement(ast* tree)é

   printf("Free_statement ...çn");
   free(tree);
   printf("Free_statement OKçn");

è

free_move_stm(ast* tree)é

   printf("Free_move_stm ...çn");
   free(tree);
   printf("Free_move_stm OK çn");

è

free_display_stm(ast* tree)é

   printf("Free_display_stm ...çn");
   free_node(tree->node.display_stm.list_operand);

   free(tree);
   printf("Free_display_stm OK çn");

è

free_initialize_stm(ast* tree)é

   printf("Free_initialize_stm ...çn");
   free(tree);
   printf("Free_initialize_stm OK çn");

è

free_operand(ast* tree)é

   printf("Free_operand ...çn");
   free(tree);
   printf("Free_operand OK çn");

è

free_literal(ast* tree)é

   printf("Free_literal ...çn");
   printf("tree (%s)(%d)çn",tagValuesÝtree->tag~,tree);
   printf("value (%s)çn",tree->node.literal.value);
   printf("tree (%s) address(%d) char_len(%d)"ç
           "  single quote (%d) alphanumeric (%d)"
                       ,tree->node.literal.value
                       ,tree
                       ,tree->node.literal.char_length
                       ,tree->node.literal.bool_singl_q
                       ,tree->node.literal.bool_alphanumeric);
   free(tree);
   printf("Free_literal OKçn");

è

free_identifier(ast* tree)é

   printf("Free_identifier ...çn");
   free_node(tree->node.identifier.name);
   free_node(tree->node.identifier.qualif);
   free_node(tree->node.identifier.subscript);
   free_node(tree->node.identifier.refmod);

   free(tree);
   printf("Free_identifier OKçn");

è

free_ident_name(ast* tree)é

   printf("Free_ident_name ...çn");
   free(tree);
   printf("Free_ident_name OK çn");

è

free_ident_name_qualif(ast* tree)é

   printf("Free_ident_name_qualif ...çn");
   free_node(tree->node.ident_name_qualif.name);
   free_node(tree->node.ident_name_qualif.qualif);

   free(tree);
   printf("Free_ident_name_qualif OK çn");

è

free_ident_qualif(ast* tree)é

   printf("Free_ident_qualif ...çn");
   free_node(tree->node.ident_qualif.list_qualif);

   free(tree); /* ?? */
   printf("Free_ident_qualif OK çn");

è

free_ident_refmod(ast* tree)é

   printf("Free_ident_refmod ...çn");
   free_node(tree->node.ident_refmod.charleft);
   free_node(tree->node.ident_refmod.length);

   free(tree);
   printf("Free_ident_refmod OK çn");

è

free_ident_subscript(ast* tree)é

   printf("Free_ident_subscript ...çn");
   free_node(tree->node.ident_subscript.list_subscript);

   free(tree);
   printf("Free_ident_subscript OK çn");

è

free_special_reg(ast* tree)é

   printf("Free_special_reg ...çn");
   free(tree);
   printf("Free_special_reg OK çn");

è

free_arith_exp(ast* tree)é

   printf("Free_arith_exp   ...çn");
   free_node(tree->node.arith_exp.left);
   free_node(tree->node.arith_exp.right);

   free(tree);
   printf("Free_arith_exp   OK çn");

è

free_unary_op(ast* tree)é

   printf("Free_unary_op    ...çn");
   free_node(tree->node.unary_op.uexp);

   free(tree);
   printf("Free_unary_op    OK çn");

è

free_binary_op(ast* tree)é

   printf("Free_binary_op    ...çn");
   free(tree);
   printf("Free_binary_op    OK çn");

è

£include <stdio.h>
£include <stdlib.h>
£include <string.h>

£include "helperh"

scr_line*
init_screen()é

   scr_line* scr=(scr_line*) malloc(sizeof(scr_line));
   scr->lvl       =-1;
   scr->valueÝ0~  ='ç0';
   scr->border    =0;
   scr->next      =NULL;

   /* printf("init_screen() succesfully.çn"); */
   return scr;

è

scr_line*
draw_box(scr_line* screen, char* value_1, char* value_2, int lvl)é

   /* printf("draw_box() start ... çn"); */


   /* level = 0 => sister */
   /* level = 1 => child  */
   /* level < 0 => parent */

   scr_line* last_line=NULL;
   scr_line* temp     =NULL;
   scr_line* ret      =NULL;

   int shift          =0;
   int length         =0;

   ret = screen;


   if(lvl > 1) é

      printf("Saut de plusieurs level non permis : %dçn",lvl);
      exit(EXIT_FAILURE);
   è

   /* get last line of screen */
   last_line =get_last_line(screen);

   if((lvl < 0) && ((last_line->lvl + lvl) < 0)) é

      printf("Parent excessive : last lvl (%d) lvl (%d)çn",
                                 last_line->lvl,lvl);
      exit(EXIT_FAILURE);
   è

   /* calculate shift                          */
   shift = (last_line->lvl + lvl) * 5;
   /* get max length of values                 */
   length= max_str_len(value_1,value_2);
   /*
   printf("draw_box():last_line->lvl  (%d) çn",last_line->lvl);
   printf("draw_box():box to draw lvl (%d) çn",lvl);
   printf("draw_box():shift           (%d) çn",shift);
   printf("draw_box():max_str_len     (%d) çn",length);
   */

   /* draw first border                        */
   temp  = draw_border(length,shift);
   /* append to screen                         */
   ret   = scr_append(ret   ,temp);

   /* draw value 1                             */
   temp  = draw_value (length,shift,value_1);
   /* append to screen                         */
   ret   = scr_append(ret   ,temp);

   /* draw value 2                             */
   temp  = draw_value (length,shift,value_2);
   /* append to screen                         */
   ret   = scr_append(ret   ,temp);

   /* draw last  border                        */
   temp  = draw_border(length,shift);
   /* append to screen                         */
   ret   = scr_append(ret   ,temp);

   /* printf("draw_box() succesfully.  çn"); */

   return ret   ;

è

scr_line*
get_last_line(scr_line* screen) é

   scr_line* temp=NULL;
   scr_line* ret =NULL;

   int i;

   temp = screen;
   ret  = temp;

   /* printf ("get_last_line() start.çn"); */

   for(i=0;temp;i++)é

   /* printf ("get_last_line() screen-%d : (%d):%sçn",
                               i,temp,temp->value); */
      ret=temp;
      temp=temp->next;
   è

   /* printf("get_last_line(): last line is the (%d th) next.çn",i);
   */
   return ret;

è

scr_line*
scr_append(scr_line* screen,scr_line* to_append) é

   scr_line* ret =NULL;

   ret =get_last_line(screen);
   ret ->next = to_append;

   /* printf("scr_append() : succesfully       .çn"); */
   return screen;

è

int
max_str_len(char* val_a, char* val_b) é

   int a,b;
   a= strlen(val_a);
   b= strlen(val_b);
   /* printf("max_str_len(): a (%d) b (%d).çn",a,b); */

   if(a>b)
     return a;
   else
     return b;
è

scr_line*
draw_border(int length, int shift) é

   scr_line* ret=(scr_line*) malloc(sizeof(scr_line));

   int lvl;
   int indent =4;
   char  tempÝ1024~;

   tempÝ0~='ç0';

   sprintf(temp,"%*s"  "%.*s"  "ç0"
           ,shift,""                     /* build shift  */
           ,length+indent, dummy_border  /* build asterisk */
           );


   /*
   strcat(buffer,temp);
   printf("temp_len = (%d)çn",temp_len);
   printf("draw_border(shift): temp=(%.*s)çn",temp_len,buffer);


   temp=h_realloc(temp,temp_len+length+indent);
   sprintf(temp+temp_len,"%.*s", length+indent, dummy_border);
   temp_len+=(length+indent);

   sprintf(temp,"%*s",length+indent, dummy_border);
   strcat(buffer,temp);
   printf("temp_len = (%d)çn",temp_len);
   printf("draw_border(***)  : temp=(%.*s)çn",temp_len,buffer);

   temp=h_realloc(temp,temp_len+1);
   sprintf(temp+temp_len,"%c", 'ç0');
   temp_len+=1;
   printf("temp_len = (%d)çn",temp_len);
   printf("draw_border(çç0)   : temp=(%.*s)çn",temp_len,temp);
   */

   strcpy(ret->value,temp);
   /* printf("draw_border()    : value=(%s)çn",ret->value); */

   /* compute level */
   lvl = shift/5;
   ret->lvl    =lvl;
   ret->border =1;
   ret->next   =NULL;

   return ret;
è


scr_line*
draw_value (int length, int shift,char* value) é

   scr_line* ret=(scr_line*) malloc(sizeof(scr_line));

   int   lvl;
   int   indent =4;
   char  tempÝ1024~;

   tempÝ0~='ç0';

   sprintf(temp,"%*s"  "%.*s"  "%c"  "%s"  "%*s"  "%c"  "%.*s"  "ç0"
           ,shift,""                     /* build shift      */
           ,1 , dummy_border             /* build asterisk 1 */
           ,' '                          /* indent 1         */
           ,value                        /* build value      */
           ,length-strlen(value),""      /* space pad to max */
           ,' '                          /* indent 2         */
           ,1 , dummy_border             /* build asterisk 2 */
           );


   /*
   temp=h_realloc(temp,temp_len+shift);
   sprintf(temp+temp_len,"%*s", shift, " ");
   temp_len+=shift;

   printf("temp_len = (%d)çn",temp_len);
   printf("draw_value (shift): temp=(%.*s)çn",temp_len,temp);

   temp=h_realloc(temp,temp_len+1);
   sprintf(temp+temp_len,"%.*s", 1,dummy_border);
   temp_len+=1;


   printf("temp_len = (%d)çn",temp_len);
   printf("draw_value (*)    : temp=(%.*s)çn",temp_len,temp);

   temp=h_realloc(temp,temp_len+1);
   sprintf(temp+temp_len,"%c", ' ');
   temp_len+=1;

   printf("temp_len = (%d)çn",temp_len);
   printf("draw_value ( )    : temp=(%.*s)çn",temp_len,temp);

   temp=h_realloc(temp,temp_len+strlen(value));
   strcpy(temp+temp_len,value);
   temp_len+=strlen(value);

   printf("temp_len = (%d)çn",temp_len);
   printf("draw_value (value): temp=(%.*s)çn",temp_len,temp);

   if(strlen(value)<length)é
      int diff=0;
      diff = length-strlen(value);
      printf("padding difference between values length (%d)çn",diff);

      temp=h_realloc(temp,temp_len+diff);
      sprintf(temp+temp_len,"%*s", diff , " ");
      temp_len+=diff;

      printf("temp_len = (%d)çn",temp_len);
      printf("draw_value (padd):temp=(%.*s)çn",temp_len,temp);

   è

   temp=h_realloc(temp,temp_len+1);
   sprintf(temp+temp_len,"%c", ' ');
   temp_len+=1;

   printf("temp_len = (%d)çn",temp_len);
   printf("draw_value ( ): temp=(%.*s)çn",temp_len,temp);

   temp=h_realloc(temp,temp_len+1);
   sprintf(temp+temp_len,"%.*s", 1,dummy_border);
   temp_len+=1;


   printf("temp_len = (%d)çn",temp_len);
   printf("draw_value (*): temp=(%.*s)çn",temp_len,temp);

   temp=h_realloc(temp,temp_len+1);
   sprintf(temp+temp_len,"%c", 'ç0');
   temp_len+=1;

   printf("temp_len = (%d)çn",temp_len);
   printf("draw_value (ç0): temp=(%.*s)çn",temp_len,temp);
   */

   strcpy(ret->value,temp);
   /* printf("draw_border() : value=(%s)çn",ret->value); */

   /* compute level */
   lvl         =shift/5;
   ret->lvl    =lvl;
   ret->border =0;
   ret->next   =NULL;

   return ret;
è

scr_line*
draw_blank ()é
   /* inutile, faire un double printf("çn") suffit */
   scr_line* ret=(scr_line*) malloc(sizeof(scr_line));

   ret->lvl          = 0;
   sprintf(ret->value,"%0*s", 1024 , " ");
   ret->valueÝ1023~  ='ç0';
   ret->border       =0;
   ret->next         =NULL;

   return ret;

è

int
print_boxes(scr_line* scr)é

   printf("printing screen boxes ... çn");

   int x   =1;
   int y   =1;
   int i;

   /*printf(" X    <%d>  Y    <%d> çn",x,y);
   */
   scr_line* temp =scr;

   /* skip first node */
   for(i=1;temp=temp->next;i++)é

    printf("%.*sçn",79,temp->value);
   /* if (§(i%4))
       printf("çn");
   */
   è

   return 0;

è

char*
h_realloc(char* temp,int size)é

   printf("çnçn");
   printf("h_realloc start. size (%d) çn",size);
   printf("h_realloc start. temp (%d) çn",temp);

   char* ret;

   printf("ret before (%d)çn",ret);
   ret=(char*) realloc(temp,(size) * sizeof(char));

   printf("ret after  (%d)çn",ret);
   printf("çn");

   if((ret==NULL) && (size>0)) é
     printf("Realloc Failed ! çn");
     exit(EXIT_FAILURE);
   è
   return ret;

è

